{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set Up Testing Infrastructure",
        "description": "Configure the testing environment with Vitest, React Testing Library, Playwright, and MSW to enable all levels of testing required by the project.",
        "details": "1. Install required dependencies:\n```bash\nnpm install --save-dev vitest @testing-library/react @testing-library/user-event @testing-library/jest-dom playwright msw vitest-coverage-report\n```\n2. Configure Vitest for unit and integration testing:\n```js\n// vitest.config.js\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: './src/test/setup.js',\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n      statements: 80,\n      branches: 75,\n      functions: 80,\n      lines: 80\n    },\n  }\n})\n```\n3. Set up Playwright for E2E testing:\n```bash\nnpx playwright install\n```\n4. Create a setup file for common test utilities:\n```js\n// src/test/setup.js\nimport '@testing-library/jest-dom'\nimport { afterAll, afterEach, beforeAll } from 'vitest'\nimport { setupServer } from 'msw/node'\n\n// Export a reusable server for API mocking\nexport const server = setupServer()\n\nbeforeAll(() => server.listen())\nafterEach(() => server.resetHandlers())\nafterAll(() => server.close())\n```\n5. Configure pre-commit hooks with Husky:\n```bash\nnpm install --save-dev husky lint-staged\nnpx husky install\nnpx husky add .husky/pre-commit \"npx lint-staged\"\n```\n6. Set up lint-staged configuration:\n```json\n// package.json\n{\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": [\"eslint --fix\", \"vitest related --run\"]\n  }\n}\n```\n7. Configure CI/CD pipeline in GitHub Actions or similar:\n```yaml\n# .github/workflows/test.yml\nname: Test Suite\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18\n      - run: npm ci\n      - run: npm run test:unit\n      - run: npm run test:e2e\n      - name: Upload coverage reports\n        uses: codecov/codecov-action@v3\n```",
        "testStrategy": "Verify the setup by running a simple test to ensure all tools are properly configured:\n1. Create a basic component test using React Testing Library\n2. Create a simple unit test with Vitest\n3. Create a basic E2E test with Playwright\n4. Verify that MSW correctly intercepts API calls\n5. Confirm that coverage reporting works\n6. Test the pre-commit hook with a sample change",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Unit Tests for Services and Stores",
        "description": "Create comprehensive unit tests for all service modules (newsService, geminiService, locationService) and Zustand stores (cartoonStore, newsStore, locationStore, preferencesStore) with proper mocking of external dependencies.",
        "details": "1. Create test files for each service:\n```js\n// src/services/__tests__/newsService.test.js\nimport { describe, it, expect, vi } from 'vitest'\nimport { fetchNews, parseArticle } from '../newsService'\nimport { server } from '../../test/setup'\nimport { rest } from 'msw'\n\ndescribe('newsService', () => {\n  it('fetches news successfully', async () => {\n    // Mock API response\n    server.use(\n      rest.get('/api/news/search', (req, res, ctx) => {\n        return res(ctx.json({ articles: [{ id: 1, title: 'Test' }] }))\n      })\n    )\n    \n    const result = await fetchNews('test location')\n    expect(result.articles).toHaveLength(1)\n    expect(result.articles[0].title).toBe('Test')\n  })\n  \n  it('handles errors gracefully', async () => {\n    server.use(\n      rest.get('/api/news/search', (req, res, ctx) => {\n        return res(ctx.status(500))\n      })\n    )\n    \n    await expect(fetchNews('test')).rejects.toThrow()\n  })\n})\n```\n\n2. Create test files for each Zustand store:\n```js\n// src/stores/__tests__/newsStore.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { createNewsStore } from '../newsStore'\nimport * as newsService from '../../services/newsService'\n\n// Mock the service\nvi.mock('../../services/newsService')\n\ndescribe('newsStore', () => {\n  let store\n  \n  beforeEach(() => {\n    // Reset mocks\n    vi.resetAllMocks()\n    // Create a fresh store for each test\n    store = createNewsStore()\n  })\n  \n  it('initializes with default state', () => {\n    const state = store.getState()\n    expect(state.articles).toEqual([])\n    expect(state.isLoading).toBe(false)\n    expect(state.error).toBe(null)\n  })\n  \n  it('fetches news and updates state', async () => {\n    // Mock the service response\n    newsService.fetchNews.mockResolvedValue({ \n      articles: [{ id: 1, title: 'Test Article' }] \n    })\n    \n    // Get the action from the store\n    const { fetchNewsForLocation } = store.getState()\n    \n    // Call the action\n    await fetchNewsForLocation('New York')\n    \n    // Check the updated state\n    const state = store.getState()\n    expect(state.articles).toHaveLength(1)\n    expect(state.articles[0].title).toBe('Test Article')\n    expect(state.isLoading).toBe(false)\n  })\n})\n```\n\n3. Test utility functions:\n```js\n// src/utils/__tests__/errorHandler.test.js\nimport { describe, it, expect, vi } from 'vitest'\nimport { handleApiError, logError } from '../errorHandler'\n\ndescribe('errorHandler', () => {\n  it('formats API errors correctly', () => {\n    const error = new Error('Network error')\n    error.status = 404\n    \n    const result = handleApiError(error)\n    expect(result.message).toContain('Network error')\n    expect(result.code).toBe(404)\n  })\n})\n```\n\n4. Create test data factories for reuse:\n```js\n// src/test/factories.js\nexport const createMockArticle = (overrides = {}) => ({\n  id: 'article-1',\n  title: 'Test Article',\n  content: 'This is test content',\n  publishedAt: '2023-11-14T12:00:00Z',\n  source: { name: 'Test Source' },\n  ...overrides\n})\n\nexport const createMockCartoon = (overrides = {}) => ({\n  id: 'cartoon-1',\n  concept: 'A funny political cartoon',\n  script: 'A detailed description of the cartoon',\n  imageUrl: 'https://example.com/image.png',\n  createdAt: '2023-11-14T12:00:00Z',\n  ...overrides\n})\n```",
        "testStrategy": "1. Test each service function with various inputs including edge cases\n2. Test error handling and recovery paths\n3. Verify store state transitions (initial → loading → success/error)\n4. Test store actions and their effects on state\n5. Verify that services are called with correct parameters\n6. Test utility functions with various inputs\n7. Run tests in isolation and verify they don't have side effects\n8. Verify mocking of external dependencies works correctly",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop Component Tests with React Testing Library",
        "description": "Create comprehensive tests for all React components to verify props, state, interactions, loading states, error states, accessibility, and responsive behavior.",
        "details": "1. Create test files for each component:\n```jsx\n// src/components/__tests__/NewsCard.test.jsx\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport NewsCard from '../NewsCard'\nimport { createMockArticle } from '../../test/factories'\n\ndescribe('NewsCard', () => {\n  it('renders article information correctly', () => {\n    const article = createMockArticle()\n    render(<NewsCard article={article} />)\n    \n    expect(screen.getByText(article.title)).toBeInTheDocument()\n    expect(screen.getByText(article.source.name)).toBeInTheDocument()\n  })\n  \n  it('calls onSelect when clicked', async () => {\n    const user = userEvent.setup()\n    const article = createMockArticle()\n    const handleSelect = vi.fn()\n    \n    render(<NewsCard article={article} onSelect={handleSelect} />)\n    \n    await user.click(screen.getByRole('button', { name: /select/i }))\n    expect(handleSelect).toHaveBeenCalledWith(article.id)\n  })\n  \n  it('shows truncated content with read more option', async () => {\n    const user = userEvent.setup()\n    const article = createMockArticle({\n      content: 'A very long article content that should be truncated'\n    })\n    \n    render(<NewsCard article={article} />)\n    \n    // Initially content is truncated\n    expect(screen.getByText(/A very long article/)).toBeInTheDocument()\n    expect(screen.getByText(/Read more/)).toBeInTheDocument()\n    \n    // Click read more\n    await user.click(screen.getByText(/Read more/))\n    \n    // Full content is shown\n    expect(screen.getByText(article.content)).toBeInTheDocument()\n  })\n})\n```\n\n2. Test loading and error states:\n```jsx\n// src/components/__tests__/NewsList.test.jsx\nimport { describe, it, expect, vi } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport NewsList from '../NewsList'\n\ndescribe('NewsList', () => {\n  it('shows loading state', () => {\n    render(<NewsList isLoading={true} articles={[]} />)\n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()\n  })\n  \n  it('shows error message', () => {\n    render(<NewsList error=\"Failed to load news\" articles={[]} />)\n    expect(screen.getByText(/Failed to load news/)).toBeInTheDocument()\n  })\n  \n  it('shows empty state when no articles', () => {\n    render(<NewsList articles={[]} />)\n    expect(screen.getByText(/No news found/)).toBeInTheDocument()\n  })\n})\n```\n\n3. Test accessibility:\n```jsx\n// src/components/__tests__/LocationInput.test.jsx\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport LocationInput from '../LocationInput'\n\ndescribe('LocationInput', () => {\n  it('is accessible via keyboard', async () => {\n    const user = userEvent.setup()\n    const handleSubmit = vi.fn()\n    \n    render(<LocationInput onSubmit={handleSubmit} />)\n    \n    // Focus the input\n    await user.tab()\n    expect(screen.getByRole('textbox')).toHaveFocus()\n    \n    // Type in the input\n    await user.keyboard('New York')\n    \n    // Tab to the button\n    await user.tab()\n    expect(screen.getByRole('button')).toHaveFocus()\n    \n    // Press Enter to submit\n    await user.keyboard('{Enter}')\n    expect(handleSubmit).toHaveBeenCalledWith('New York')\n  })\n  \n  it('has proper ARIA attributes', () => {\n    render(<LocationInput />)\n    \n    const input = screen.getByRole('textbox')\n    expect(input).toHaveAttribute('aria-label', 'Enter location')\n    \n    // Check for other ARIA attributes\n    expect(input).toHaveAttribute('aria-required', 'true')\n  })\n})\n```\n\n4. Test responsive behavior:\n```jsx\n// src/components/__tests__/CartoonDisplay.test.jsx\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport CartoonDisplay from '../CartoonDisplay'\nimport { createMockCartoon } from '../../test/factories'\n\ndescribe('CartoonDisplay', () => {\n  let originalInnerWidth\n  \n  beforeEach(() => {\n    originalInnerWidth = window.innerWidth\n    Object.defineProperty(window, 'innerWidth', {\n      writable: true,\n      configurable: true,\n      value: 1200 // Desktop by default\n    })\n  })\n  \n  afterEach(() => {\n    Object.defineProperty(window, 'innerWidth', {\n      writable: true,\n      configurable: true,\n      value: originalInnerWidth\n    })\n  })\n  \n  it('renders in desktop layout', () => {\n    const cartoon = createMockCartoon()\n    render(<CartoonDisplay cartoon={cartoon} />)\n    \n    // Check desktop-specific elements\n    expect(screen.getByTestId('desktop-controls')).toBeInTheDocument()\n  })\n  \n  it('renders in mobile layout', () => {\n    // Set mobile width\n    window.innerWidth = 480\n    \n    const cartoon = createMockCartoon()\n    render(<CartoonDisplay cartoon={cartoon} />)\n    \n    // Check mobile-specific elements\n    expect(screen.getByTestId('mobile-controls')).toBeInTheDocument()\n  })\n})\n```",
        "testStrategy": "1. Test each component with various props and states\n2. Verify component rendering and conditional logic\n3. Test user interactions using userEvent\n4. Validate accessibility using ARIA attributes and keyboard navigation\n5. Test responsive behavior by mocking window dimensions\n6. Verify loading, error, and empty states\n7. Test component lifecycle methods and hooks\n8. Verify event handlers are called with correct parameters",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create Integration Tests for Data Flow",
        "description": "Implement integration tests that verify the correct data flow between services, stores, and components, including API request/response cycles and error propagation.",
        "details": "1. Test service-to-store integration:\n```jsx\n// src/integration/__tests__/newsFlow.test.jsx\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { server } from '../../test/setup'\nimport { rest } from 'msw'\nimport { NewsProvider, useNewsStore } from '../../stores/newsStore'\nimport NewsSearch from '../../components/NewsSearch'\n\ndescribe('News Search Flow', () => {\n  beforeEach(() => {\n    // Reset MSW handlers\n    server.resetHandlers()\n  })\n  \n  it('fetches and displays news based on location input', async () => {\n    const user = userEvent.setup()\n    \n    // Mock the API response\n    server.use(\n      rest.get('/api/news/search', (req, res, ctx) => {\n        const location = req.url.searchParams.get('location')\n        if (location === 'New York') {\n          return res(ctx.json({\n            articles: [\n              { id: 1, title: 'NY News 1', source: { name: 'Test Source' } },\n              { id: 2, title: 'NY News 2', source: { name: 'Test Source' } }\n            ]\n          }))\n        }\n        return res(ctx.status(404))\n      })\n    )\n    \n    // Create a test component that uses the store\n    const TestComponent = () => {\n      const { articles, isLoading } = useNewsStore()\n      return (\n        <div>\n          <NewsSearch />\n          {isLoading && <div data-testid=\"loading\">Loading...</div>}\n          <ul>\n            {articles.map(article => (\n              <li key={article.id}>{article.title}</li>\n            ))}\n          </ul>\n        </div>\n      )\n    }\n    \n    // Render with the provider\n    render(\n      <NewsProvider>\n        <TestComponent />\n      </NewsProvider>\n    )\n    \n    // Enter a location\n    const input = screen.getByRole('textbox')\n    await user.type(input, 'New York')\n    \n    // Submit the form\n    const button = screen.getByRole('button', { name: /search/i })\n    await user.click(button)\n    \n    // Should show loading state\n    expect(screen.getByTestId('loading')).toBeInTheDocument()\n    \n    // Wait for results\n    await waitFor(() => {\n      expect(screen.getByText('NY News 1')).toBeInTheDocument()\n      expect(screen.getByText('NY News 2')).toBeInTheDocument()\n    })\n  })\n  \n  it('handles API errors correctly', async () => {\n    const user = userEvent.setup()\n    \n    // Mock API error\n    server.use(\n      rest.get('/api/news/search', (req, res, ctx) => {\n        return res(ctx.status(500, 'Server error'))\n      })\n    )\n    \n    // Create a test component that shows errors\n    const TestComponent = () => {\n      const { error, fetchNewsForLocation } = useNewsStore()\n      return (\n        <div>\n          <button onClick={() => fetchNewsForLocation('Test')}>Fetch</button>\n          {error && <div data-testid=\"error\">{error}</div>}\n        </div>\n      )\n    }\n    \n    // Render with the provider\n    render(\n      <NewsProvider>\n        <TestComponent />\n      </NewsProvider>\n    )\n    \n    // Trigger the fetch\n    await user.click(screen.getByRole('button', { name: /fetch/i }))\n    \n    // Should show error state\n    await waitFor(() => {\n      expect(screen.getByTestId('error')).toBeInTheDocument()\n    })\n  })\n})\n```\n\n2. Test cartoon generation flow:\n```jsx\n// src/integration/__tests__/cartoonGeneration.test.jsx\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { server } from '../../test/setup'\nimport { rest } from 'msw'\nimport { CartoonProvider, useCartoonStore } from '../../stores/cartoonStore'\nimport { NewsProvider, useNewsStore } from '../../stores/newsStore'\nimport CartoonGenerator from '../../components/CartoonGenerator'\nimport { createMockArticle } from '../../test/factories'\n\ndescribe('Cartoon Generation Flow', () => {\n  beforeEach(() => {\n    server.resetHandlers()\n  })\n  \n  it('generates a cartoon from selected news article', async () => {\n    const user = userEvent.setup()\n    \n    // Mock API responses\n    server.use(\n      rest.post('/api/gemini/concept', (req, res, ctx) => {\n        return res(ctx.json({\n          concept: 'A satirical cartoon about politics'\n        }))\n      }),\n      rest.post('/api/gemini/script', (req, res, ctx) => {\n        return res(ctx.json({\n          script: 'A detailed description of the cartoon'\n        }))\n      }),\n      rest.post('/api/gemini/image', (req, res, ctx) => {\n        return res(ctx.json({\n          imageUrl: 'https://example.com/cartoon.png'\n        }))\n      })\n    )\n    \n    // Create a test component\n    const TestComponent = () => {\n      const { selectArticle } = useNewsStore()\n      const { cartoon, isGenerating } = useCartoonStore()\n      \n      return (\n        <div>\n          <button \n            onClick={() => selectArticle(createMockArticle())}\n          >\n            Select Article\n          </button>\n          <CartoonGenerator />\n          {isGenerating && <div data-testid=\"generating\">Generating...</div>}\n          {cartoon && (\n            <div data-testid=\"cartoon\">\n              <div>{cartoon.concept}</div>\n              <div>{cartoon.script}</div>\n              <img src={cartoon.imageUrl} alt=\"Generated cartoon\" />\n            </div>\n          )}\n        </div>\n      )\n    }\n    \n    // Render with providers\n    render(\n      <NewsProvider>\n        <CartoonProvider>\n          <TestComponent />\n        </CartoonProvider>\n      </NewsProvider>\n    )\n    \n    // Select an article\n    await user.click(screen.getByRole('button', { name: /select article/i }))\n    \n    // Click generate\n    await user.click(screen.getByRole('button', { name: /generate cartoon/i }))\n    \n    // Should show generating state\n    expect(screen.getByTestId('generating')).toBeInTheDocument()\n    \n    // Wait for cartoon to be generated\n    await waitFor(() => {\n      expect(screen.getByTestId('cartoon')).toBeInTheDocument()\n      expect(screen.getByText('A satirical cartoon about politics')).toBeInTheDocument()\n      expect(screen.getByText('A detailed description of the cartoon')).toBeInTheDocument()\n      expect(screen.getByAltText('Generated cartoon')).toHaveAttribute(\n        'src', 'https://example.com/cartoon.png'\n      )\n    })\n  })\n})\n```",
        "testStrategy": "1. Test complete flows from user input to UI updates\n2. Mock API responses using MSW to simulate backend behavior\n3. Verify data is correctly passed between components and stores\n4. Test error propagation through the application\n5. Verify loading states are shown and cleared appropriately\n6. Test rate limiting and caching behavior\n7. Verify that stores update correctly based on service responses\n8. Test that UI components react appropriately to store changes",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement End-to-End Tests with Playwright",
        "description": "Create comprehensive end-to-end tests using Playwright to verify critical user journeys, cross-browser compatibility, and mobile responsiveness.",
        "details": "1. Set up Playwright configuration:\n```js\n// playwright.config.js\nimport { defineConfig } from '@playwright/test'\n\nexport default defineConfig({\n  testDir: './e2e',\n  timeout: 30000,\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure'\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { browserName: 'chromium' }\n    },\n    {\n      name: 'firefox',\n      use: { browserName: 'firefox' }\n    },\n    {\n      name: 'webkit',\n      use: { browserName: 'webkit' }\n    },\n    {\n      name: 'Mobile Chrome',\n      use: {\n        browserName: 'chromium',\n        viewport: { width: 414, height: 896 },\n        deviceScaleFactor: 2,\n        isMobile: true\n      }\n    }\n  ],\n  webServer: {\n    command: 'npm run dev',\n    port: 3000,\n    reuseExistingServer: !process.env.CI\n  }\n})\n```\n\n2. Create test for location detection and news fetching:\n```js\n// e2e/location-detection.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('detects user location and fetches news', async ({ page }) => {\n  // Mock geolocation API\n  await page.addInitScript(() => {\n    const mockGeolocation = {\n      getCurrentPosition: (success) => {\n        success({\n          coords: {\n            latitude: 40.7128,\n            longitude: -74.0060\n          }\n        })\n      }\n    }\n    navigator.geolocation = mockGeolocation\n  })\n  \n  // Go to homepage\n  await page.goto('/')\n  \n  // Click allow location button if it appears\n  const allowButton = page.locator('button:has-text(\"Allow Location\")')\n  if (await allowButton.isVisible())\n    await allowButton.click()\n  \n  // Wait for location to be detected\n  await expect(page.locator('text=New York')).toBeVisible()\n  \n  // Wait for news to load\n  await expect(page.locator('.news-card')).toBeVisible()\n  \n  // Verify multiple news items are displayed\n  const newsCards = page.locator('.news-card')\n  await expect(newsCards).toHaveCount(await newsCards.count())\n  expect(await newsCards.count()).toBeGreaterThan(0)\n})\n```\n\n3. Test manual location entry:\n```js\n// e2e/manual-location.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('allows manual location entry and search', async ({ page }) => {\n  // Go to homepage\n  await page.goto('/')\n  \n  // Find and click the manual location entry button\n  await page.click('button:has-text(\"Enter Location Manually\")')\n  \n  // Type a location\n  await page.fill('input[placeholder=\"Enter location\"]', 'Chicago')\n  \n  // Submit the form\n  await page.click('button:has-text(\"Search\")')\n  \n  // Wait for location to update\n  await expect(page.locator('text=Chicago')).toBeVisible()\n  \n  // Wait for news to load\n  await expect(page.locator('.news-card')).toBeVisible()\n  \n  // Verify news items are for Chicago\n  const newsText = await page.locator('.news-container').textContent()\n  expect(newsText.toLowerCase()).toContain('chicago')\n})\n```\n\n4. Test cartoon generation flow:\n```js\n// e2e/cartoon-generation.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('generates cartoon from selected news article', async ({ page }) => {\n  // Go to homepage and wait for news to load\n  await page.goto('/')\n  await expect(page.locator('.news-card')).toBeVisible()\n  \n  // Select the first news article\n  await page.click('.news-card:first-child')\n  \n  // Verify article is selected\n  await expect(page.locator('.selected-article')).toBeVisible()\n  \n  // Click generate cartoon button\n  await page.click('button:has-text(\"Generate Cartoon\")')\n  \n  // Wait for concept generation\n  await expect(page.locator('text=Generating concept...')).toBeVisible()\n  await expect(page.locator('.cartoon-concept')).toBeVisible({ timeout: 30000 })\n  \n  // Wait for script generation\n  await expect(page.locator('text=Generating script...')).toBeVisible()\n  await expect(page.locator('.cartoon-script')).toBeVisible({ timeout: 30000 })\n  \n  // Wait for image generation\n  await expect(page.locator('text=Generating image...')).toBeVisible()\n  await expect(page.locator('.cartoon-image')).toBeVisible({ timeout: 60000 })\n  \n  // Verify the cartoon is displayed\n  await expect(page.locator('.cartoon-container img')).toBeVisible()\n})\n```\n\n5. Test settings persistence:\n```js\n// e2e/settings-persistence.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('persists user preferences across sessions', async ({ page }) => {\n  // Go to settings page\n  await page.goto('/settings')\n  \n  // Change theme to dark\n  await page.click('text=Dark Theme')\n  \n  // Change language to Spanish\n  await page.selectOption('select[name=\"language\"]', 'es')\n  \n  // Save settings\n  await page.click('button:has-text(\"Save Settings\")')\n  \n  // Verify settings saved confirmation\n  await expect(page.locator('text=Settings saved')).toBeVisible()\n  \n  // Reload the page to simulate new session\n  await page.reload()\n  \n  // Verify settings persisted\n  await expect(page.locator('input[name=\"darkTheme\"]')).toBeChecked()\n  await expect(page.locator('select[name=\"language\"]')).toHaveValue('es')\n  \n  // Verify theme applied to UI\n  await expect(page.locator('body')).toHaveClass(/dark-theme/)\n})\n```\n\n6. Test error recovery flows:\n```js\n// e2e/error-recovery.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('recovers from API errors', async ({ page }) => {\n  // Mock a failed API response\n  await page.route('**/api/news/search**', route => {\n    route.fulfill({\n      status: 500,\n      body: JSON.stringify({ error: 'Server error' })\n    })\n  })\n  \n  // Go to homepage\n  await page.goto('/')\n  \n  // Verify error message is displayed\n  await expect(page.locator('text=Failed to load news')).toBeVisible()\n  \n  // Click retry button\n  await page.click('button:has-text(\"Retry\")')\n  \n  // Remove the mock to allow success\n  await page.unroute('**/api/news/search**')\n  \n  // Verify news loads successfully after retry\n  await expect(page.locator('.news-card')).toBeVisible({ timeout: 10000 })\n})\n```",
        "testStrategy": "1. Test all critical user journeys from start to finish\n2. Verify application works across multiple browsers (Chrome, Firefox, Safari)\n3. Test mobile responsiveness with different viewport sizes\n4. Mock geolocation API for consistent location testing\n5. Test error scenarios and recovery paths\n6. Verify data persistence across page reloads\n7. Test rate limiting behavior with rapid requests\n8. Capture screenshots and videos on test failures for debugging",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement API and Performance Tests",
        "description": "Create tests for backend API endpoints and application performance, including request validation, error responses, render performance, bundle size, and memory usage.",
        "details": "1. API endpoint testing:\n```js\n// src/api/__tests__/newsEndpoints.test.js\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest'\nimport { createServer } from '../../server'\nimport request from 'supertest'\n\ndescribe('News API Endpoints', () => {\n  let server\n  \n  beforeAll(() => {\n    server = createServer()\n  })\n  \n  afterAll(() => {\n    server.close()\n  })\n  \n  it('returns news articles for valid location', async () => {\n    const response = await request(server)\n      .get('/api/news/search')\n      .query({ location: 'New York' })\n    \n    expect(response.status).toBe(200)\n    expect(response.body).toHaveProperty('articles')\n    expect(Array.isArray(response.body.articles)).toBe(true)\n  })\n  \n  it('validates location parameter', async () => {\n    const response = await request(server)\n      .get('/api/news/search')\n      .query({ location: '' })\n    \n    expect(response.status).toBe(400)\n    expect(response.body).toHaveProperty('error')\n  })\n  \n  it('sanitizes location input', async () => {\n    const response = await request(server)\n      .get('/api/news/search')\n      .query({ location: '<script>alert(\"XSS\")</script>' })\n    \n    expect(response.status).toBe(200)\n    // Verify the script tags were sanitized\n    const requestLogs = server.getRequestLogs()\n    const lastLog = requestLogs[requestLogs.length - 1]\n    expect(lastLog.sanitizedParams.location).not.toContain('<script>')\n  })\n  \n  it('returns article content for valid ID', async () => {\n    const response = await request(server)\n      .get('/api/article/content')\n      .query({ id: 'valid-article-id' })\n    \n    expect(response.status).toBe(200)\n    expect(response.body).toHaveProperty('content')\n  })\n  \n  it('handles rate limiting', async () => {\n    // Make multiple requests in quick succession\n    const promises = Array(10).fill().map(() => \n      request(server).get('/api/news/search').query({ location: 'Test' })\n    )\n    \n    const responses = await Promise.all(promises)\n    \n    // At least one should be rate limited\n    const rateLimited = responses.some(res => res.status === 429)\n    expect(rateLimited).toBe(true)\n  })\n})\n```\n\n2. CORS configuration testing:\n```js\n// src/api/__tests__/cors.test.js\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest'\nimport { createServer } from '../../server'\nimport request from 'supertest'\n\ndescribe('CORS Configuration', () => {\n  let server\n  \n  beforeAll(() => {\n    server = createServer()\n  })\n  \n  afterAll(() => {\n    server.close()\n  })\n  \n  it('allows requests from allowed origins', async () => {\n    const response = await request(server)\n      .get('/api/news/search')\n      .set('Origin', 'https://news-cartoon.example.com')\n      .query({ location: 'Test' })\n    \n    expect(response.headers['access-control-allow-origin']).toBe('https://news-cartoon.example.com')\n  })\n  \n  it('blocks requests from disallowed origins', async () => {\n    const response = await request(server)\n      .get('/api/news/search')\n      .set('Origin', 'https://malicious-site.com')\n      .query({ location: 'Test' })\n    \n    expect(response.headers['access-control-allow-origin']).toBeUndefined()\n  })\n})\n```\n\n3. Component render performance testing:\n```jsx\n// src/performance/__tests__/renderPerformance.test.jsx\nimport { describe, it, expect } from 'vitest'\nimport { render } from '@testing-library/react'\nimport { PerformanceObserver } from 'perf_hooks'\nimport NewsList from '../../components/NewsList'\nimport { createMockArticle } from '../../test/factories'\n\ndescribe('Component Render Performance', () => {\n  it('renders NewsList within performance budget', () => {\n    // Create test data\n    const articles = Array(20).fill().map((_, i) => \n      createMockArticle({ id: `article-${i}` })\n    )\n    \n    // Track render duration\n    let renderDuration = 0\n    const observer = new PerformanceObserver((list) => {\n      const entries = list.getEntries()\n      renderDuration = entries[0].duration\n    })\n    observer.observe({ entryTypes: ['measure'] })\n    \n    // Measure render time\n    performance.mark('render-start')\n    render(<NewsList articles={articles} />)\n    performance.mark('render-end')\n    performance.measure('render', 'render-start', 'render-end')\n    \n    // Cleanup\n    observer.disconnect()\n    \n    // Assert render time is within budget\n    expect(renderDuration).toBeLessThan(100) // 100ms budget\n  })\n})\n```\n\n4. Bundle size testing:\n```js\n// scripts/test-bundle-size.js\nconst fs = require('fs')\nconst path = require('path')\nconst chalk = require('chalk')\n\n// Define size limits\nconst LIMITS = {\n  'main.js': 250 * 1024, // 250KB\n  'vendor.js': 500 * 1024, // 500KB\n}\n\n// Get build directory\nconst buildDir = path.join(__dirname, '../dist/assets')\n\n// Check if directory exists\nif (!fs.existsSync(buildDir)) {\n  console.error('Build directory not found. Run build first.')\n  process.exit(1)\n}\n\n// Get files\nconst files = fs.readdirSync(buildDir)\n\n// Check each file against limits\nlet failedChecks = 0\n\nfiles.forEach(file => {\n  // Find matching limit\n  const limitKey = Object.keys(LIMITS).find(key => file.includes(key))\n  if (!limitKey) return\n  \n  const filePath = path.join(buildDir, file)\n  const stats = fs.statSync(filePath)\n  const sizeKB = stats.size / 1024\n  \n  console.log(`${file}: ${Math.round(sizeKB)}KB`)\n  \n  if (stats.size > LIMITS[limitKey]) {\n    console.error(\n      chalk.red(`❌ ${file} exceeds size limit of ${LIMITS[limitKey] / 1024}KB`)\n    )\n    failedChecks++\n  } else {\n    console.log(\n      chalk.green(`✓ ${file} is within size limit of ${LIMITS[limitKey] / 1024}KB`)\n    )\n  }\n})\n\n// Exit with error if any checks failed\nprocess.exit(failedChecks > 0 ? 1 : 0)\n```\n\n5. Memory usage testing:\n```js\n// src/performance/__tests__/memoryUsage.test.js\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport CartoonGenerator from '../../components/CartoonGenerator'\n\ndescribe('Memory Usage', () => {\n  it('does not leak memory during cartoon generation', async () => {\n    const user = userEvent.setup()\n    \n    // Get initial memory usage\n    const initialMemory = performance.memory?.usedJSHeapSize || 0\n    \n    // Render component\n    render(<CartoonGenerator />)\n    \n    // Perform actions that might cause memory issues\n    for (let i = 0; i < 5; i++) {\n      await user.click(screen.getByRole('button', { name: /generate/i }))\n      // Wait for generation to complete\n      await new Promise(r => setTimeout(r, 100))\n    }\n    \n    // Force garbage collection if available (Node.js environment)\n    if (global.gc) {\n      global.gc()\n    }\n    \n    // Get final memory usage\n    const finalMemory = performance.memory?.usedJSHeapSize || 0\n    \n    // Check memory increase is reasonable (less than 50% increase)\n    const increase = finalMemory - initialMemory\n    const percentIncrease = (increase / initialMemory) * 100\n    \n    expect(percentIncrease).toBeLessThan(50)\n  })\n})\n```",
        "testStrategy": "1. Test all API endpoints with valid and invalid inputs\n2. Verify request validation and sanitization\n3. Test error responses and status codes\n4. Verify CORS configuration works correctly\n5. Test rate limiting behavior\n6. Measure component render performance against budgets\n7. Verify bundle sizes are within limits\n8. Test memory usage patterns to detect leaks\n9. Measure API response times against thresholds\n10. Test lazy loading effectiveness",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Set Up Visual Regression Testing",
        "description": "Implement visual regression testing to detect unintended visual changes in the UI components and layouts across different browsers and screen sizes.",
        "details": "1. Install and configure Playwright for visual testing:\n```bash\nnpm install --save-dev @playwright/test\n```\n\n2. Create a visual regression test configuration:\n```js\n// playwright-visual.config.js\nimport { defineConfig } from '@playwright/test'\n\nexport default defineConfig({\n  testDir: './visual-tests',\n  timeout: 30000,\n  expect: {\n    toMatchSnapshot: { threshold: 0.2 }\n  },\n  retries: 0,\n  reporter: 'html',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'on'\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { browserName: 'chromium' }\n    },\n    {\n      name: 'firefox',\n      use: { browserName: 'firefox' }\n    },\n    {\n      name: 'webkit',\n      use: { browserName: 'webkit' }\n    },\n    {\n      name: 'mobile',\n      use: {\n        browserName: 'chromium',\n        viewport: { width: 414, height: 896 },\n        deviceScaleFactor: 2,\n        isMobile: true\n      }\n    }\n  ],\n  webServer: {\n    command: 'npm run dev',\n    port: 3000,\n    reuseExistingServer: !process.env.CI\n  }\n})\n```\n\n3. Create visual tests for key components and pages:\n```js\n// visual-tests/components.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Visual regression tests', () => {\n  test('NewsCard component', async ({ page }) => {\n    // Navigate to component preview page\n    await page.goto('/test-components?component=NewsCard')\n    \n    // Wait for component to fully render\n    await page.waitForSelector('.news-card', { state: 'visible' })\n    \n    // Take screenshot and compare with baseline\n    await expect(page.locator('.news-card')).toHaveScreenshot('news-card.png')\n  })\n  \n  test('CartoonDisplay component', async ({ page }) => {\n    // Navigate to component preview page\n    await page.goto('/test-components?component=CartoonDisplay')\n    \n    // Wait for component to fully render\n    await page.waitForSelector('.cartoon-display', { state: 'visible' })\n    \n    // Take screenshot and compare with baseline\n    await expect(page.locator('.cartoon-display')).toHaveScreenshot('cartoon-display.png')\n  })\n  \n  test('LocationInput component', async ({ page }) => {\n    // Navigate to component preview page\n    await page.goto('/test-components?component=LocationInput')\n    \n    // Wait for component to fully render\n    await page.waitForSelector('.location-input', { state: 'visible' })\n    \n    // Take screenshot and compare with baseline\n    await expect(page.locator('.location-input')).toHaveScreenshot('location-input.png')\n  })\n})\n```\n\n4. Create visual tests for different states:\n```js\n// visual-tests/states.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Component states', () => {\n  test('NewsCard loading state', async ({ page }) => {\n    await page.goto('/test-components?component=NewsCard&state=loading')\n    await page.waitForSelector('.news-card-skeleton', { state: 'visible' })\n    await expect(page.locator('.news-card-skeleton')).toHaveScreenshot('news-card-loading.png')\n  })\n  \n  test('NewsCard error state', async ({ page }) => {\n    await page.goto('/test-components?component=NewsCard&state=error')\n    await page.waitForSelector('.news-card-error', { state: 'visible' })\n    await expect(page.locator('.news-card-error')).toHaveScreenshot('news-card-error.png')\n  })\n  \n  test('CartoonDisplay generation states', async ({ page }) => {\n    // Test concept generation state\n    await page.goto('/test-components?component=CartoonDisplay&state=generating-concept')\n    await page.waitForSelector('.generating-concept', { state: 'visible' })\n    await expect(page.locator('.cartoon-display')).toHaveScreenshot('cartoon-generating-concept.png')\n    \n    // Test script generation state\n    await page.goto('/test-components?component=CartoonDisplay&state=generating-script')\n    await page.waitForSelector('.generating-script', { state: 'visible' })\n    await expect(page.locator('.cartoon-display')).toHaveScreenshot('cartoon-generating-script.png')\n    \n    // Test image generation state\n    await page.goto('/test-components?component=CartoonDisplay&state=generating-image')\n    await page.waitForSelector('.generating-image', { state: 'visible' })\n    await expect(page.locator('.cartoon-display')).toHaveScreenshot('cartoon-generating-image.png')\n  })\n})\n```\n\n5. Create visual tests for theme variations:\n```js\n// visual-tests/themes.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Theme variations', () => {\n  test('Light theme', async ({ page }) => {\n    await page.goto('/?theme=light')\n    await page.waitForSelector('body.light-theme', { state: 'visible' })\n    await expect(page).toHaveScreenshot('homepage-light.png')\n  })\n  \n  test('Dark theme', async ({ page }) => {\n    await page.goto('/?theme=dark')\n    await page.waitForSelector('body.dark-theme', { state: 'visible' })\n    await expect(page).toHaveScreenshot('homepage-dark.png')\n  })\n  \n  test('High contrast theme', async ({ page }) => {\n    await page.goto('/?theme=high-contrast')\n    await page.waitForSelector('body.high-contrast-theme', { state: 'visible' })\n    await expect(page).toHaveScreenshot('homepage-high-contrast.png')\n  })\n})\n```\n\n6. Create a script to update baseline screenshots:\n```js\n// scripts/update-visual-baselines.js\nconst { execSync } = require('child_process')\nconst path = require('path')\n\nconsole.log('Updating visual test baselines...')\n\ntry {\n  // Run Playwright tests with update flag\n  execSync('npx playwright test --config=playwright-visual.config.js -u', {\n    stdio: 'inherit',\n    cwd: path.resolve(__dirname, '..')\n  })\n  \n  console.log('✅ Visual test baselines updated successfully')\n} catch (error) {\n  console.error('❌ Failed to update visual test baselines:', error.message)\n  process.exit(1)\n}\n```\n\n7. Add scripts to package.json:\n```json\n{\n  \"scripts\": {\n    \"test:visual\": \"playwright test --config=playwright-visual.config.js\",\n    \"test:visual:update\": \"node scripts/update-visual-baselines.js\"\n  }\n}\n```\n\n8. Create a component test page for visual testing:\n```jsx\n// src/pages/test-components.jsx\nimport { useEffect, useState } from 'react'\nimport { useSearchParams } from 'react-router-dom'\nimport NewsCard from '../components/NewsCard'\nimport CartoonDisplay from '../components/CartoonDisplay'\nimport LocationInput from '../components/LocationInput'\nimport { createMockArticle, createMockCartoon } from '../test/factories'\n\nconst TestComponents = () => {\n  const [searchParams] = useSearchParams()\n  const component = searchParams.get('component')\n  const state = searchParams.get('state')\n  \n  // Create test data based on component and state\n  const getTestData = () => {\n    switch (component) {\n      case 'NewsCard':\n        return {\n          article: createMockArticle(),\n          isLoading: state === 'loading',\n          hasError: state === 'error'\n        }\n      case 'CartoonDisplay':\n        return {\n          cartoon: state?.includes('generating') ? null : createMockCartoon(),\n          isGeneratingConcept: state === 'generating-concept',\n          isGeneratingScript: state === 'generating-script',\n          isGeneratingImage: state === 'generating-image'\n        }\n      default:\n        return {}\n    }\n  }\n  \n  const renderComponent = () => {\n    const testData = getTestData()\n    \n    switch (component) {\n      case 'NewsCard':\n        return <NewsCard \n          article={testData.article} \n          isLoading={testData.isLoading}\n          hasError={testData.hasError}\n        />\n      case 'CartoonDisplay':\n        return <CartoonDisplay \n          cartoon={testData.cartoon}\n          isGeneratingConcept={testData.isGeneratingConcept}\n          isGeneratingScript={testData.isGeneratingScript}\n          isGeneratingImage={testData.isGeneratingImage}\n        />\n      case 'LocationInput':\n        return <LocationInput />\n      default:\n        return <div>Select a component to test</div>\n    }\n  }\n  \n  return (\n    <div className=\"test-component-container\">\n      {renderComponent()}\n    </div>\n  )\n}\n\nexport default TestComponents\n```",
        "testStrategy": "1. Create baseline screenshots for all key components\n2. Test components in different states (loading, error, success)\n3. Test different themes and visual variations\n4. Test responsive layouts across different screen sizes\n5. Run visual tests in multiple browsers\n6. Set appropriate threshold for pixel differences\n7. Update baselines when intentional visual changes are made\n8. Integrate visual tests into CI/CD pipeline\n9. Create a component test page to isolate components for testing",
        "priority": "low",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Test Documentation and Guidelines",
        "description": "Develop comprehensive test documentation including testing strategy, guidelines for contributors, test running procedures, and troubleshooting guides.",
        "details": "1. Create a main testing documentation file:\n```markdown\n# News Cartoon Application Testing Guide\n\n## Overview\n\nThis document outlines the testing strategy and guidelines for the News Cartoon application. It covers all levels of testing from unit tests to end-to-end tests, as well as performance and visual regression testing.\n\n## Testing Stack\n\n- **Unit & Integration Testing**: Vitest + React Testing Library\n- **Component Testing**: React Testing Library + Testing Library User Event\n- **E2E Testing**: Playwright\n- **API Mocking**: Mock Service Worker (MSW)\n- **Visual Regression**: Playwright\n- **Performance Testing**: Custom utilities + Lighthouse\n\n## Test Directory Structure\n\n```\n├── src/\n│   ├── __tests__/            # Global test utilities and setup\n│   ├── components/\n│   │   └── __tests__/        # Component tests\n│   ├── services/\n│   │   └── __tests__/        # Service tests\n│   ├── stores/\n│   │   └── __tests__/        # Store tests\n│   └── utils/\n│       └── __tests__/        # Utility function tests\n├── e2e/                      # End-to-end tests\n├── visual-tests/             # Visual regression tests\n└── performance/              # Performance tests\n```\n\n## Running Tests\n\n### Unit and Integration Tests\n\n```bash\n# Run all unit and integration tests\nnpm run test\n\n# Run tests in watch mode during development\nnpm run test:watch\n\n# Run tests with coverage report\nnpm run test:coverage\n```\n\n### End-to-End Tests\n\n```bash\n# Run all E2E tests\nnpm run test:e2e\n\n# Run E2E tests in headed mode (visible browser)\nnpm run test:e2e:headed\n\n# Run E2E tests for a specific browser\nnpm run test:e2e -- --project=firefox\n```\n\n### Visual Regression Tests\n\n```bash\n# Run visual regression tests\nnpm run test:visual\n\n# Update visual baselines\nnpm run test:visual:update\n```\n\n### Performance Tests\n\n```bash\n# Run performance tests\nnpm run test:performance\n\n# Check bundle sizes\nnpm run test:bundle-size\n```\n```\n\n2. Create testing guidelines for contributors:\n```markdown\n# Testing Guidelines for Contributors\n\n## General Principles\n\n1. **Test Behavior, Not Implementation**: Focus on what the code does, not how it does it.\n2. **Keep Tests Simple**: Tests should be easy to understand and maintain.\n3. **One Assertion Per Test**: When possible, test one thing per test case.\n4. **Use Descriptive Test Names**: Test names should describe what is being tested.\n5. **Isolate Tests**: Tests should not depend on each other.\n\n## Writing Unit Tests\n\n### For Services\n\n- Mock external dependencies (API calls, browser APIs)\n- Test success and error paths\n- Verify correct parameters are passed to dependencies\n- Test edge cases and input validation\n\nExample:\n\n```jsx\nimport { describe, it, expect, vi } from 'vitest'\nimport { fetchNews } from '../newsService'\n\ndescribe('newsService', () => {\n  it('calls API with correct parameters', async () => {\n    // Arrange\n    const mockFetch = vi.fn().mockResolvedValue({\n      ok: true,\n      json: () => Promise.resolve({ articles: [] })\n    })\n    global.fetch = mockFetch\n    \n    // Act\n    await fetchNews('New York')\n    \n    // Assert\n    expect(mockFetch).toHaveBeenCalledWith(\n      expect.stringContaining('/api/news/search?location=New%20York'),\n      expect.any(Object)\n    )\n  })\n})\n```\n\n### For Components\n\n- Test rendering with different props\n- Test user interactions\n- Test accessibility\n- Test different states (loading, error, empty)\n\nExample:\n\n```jsx\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport Button from '../Button'\n\ndescribe('Button', () => {\n  it('renders children correctly', () => {\n    render(<Button>Click me</Button>)\n    expect(screen.getByText('Click me')).toBeInTheDocument()\n  })\n  \n  it('calls onClick when clicked', async () => {\n    const handleClick = vi.fn()\n    const user = userEvent.setup()\n    \n    render(<Button onClick={handleClick}>Click me</Button>)\n    \n    await user.click(screen.getByRole('button'))\n    expect(handleClick).toHaveBeenCalledTimes(1)\n  })\n})\n```\n```\n\n3. Create test running and debugging procedures:\n```markdown\n# Test Running and Debugging Guide\n\n## Running Tests During Development\n\nDuring development, it's recommended to run tests in watch mode:\n\n```bash\nnpm run test:watch\n```\n\nThis will run only the tests related to changed files, making the feedback loop faster.\n\n## Debugging Failed Tests\n\n### Unit and Integration Tests\n\n1. Use `console.log` statements to inspect values\n2. Use the `debug()` function from React Testing Library:\n   ```jsx\n   const { debug } = render(<MyComponent />)\n   debug()\n   ```\n3. Use the Vitest UI for interactive debugging:\n   ```bash\n   npm run test:ui\n   ```\n\n### End-to-End Tests\n\n1. Run tests in headed mode to see what's happening:\n   ```bash\n   npm run test:e2e:headed\n   ```\n2. Use `page.pause()` to pause execution at a specific point:\n   ```js\n   test('example', async ({ page }) => {\n     await page.goto('/')\n     await page.pause() // Execution will pause here\n   })\n   ```\n3. Review screenshots and videos in the test results folder\n\n## Common Issues and Solutions\n\n### Tests Timing Out\n\n- Increase timeout in the test configuration\n- Check if you're waiting for the right elements\n- Verify that mocks are properly set up\n\n### Flaky Tests\n\n- Avoid timing-dependent tests\n- Use proper waiting mechanisms instead of fixed delays\n- Isolate tests from each other\n- Reset state between tests\n\n### Snapshot Mismatches\n\n- Review the differences carefully\n- Update snapshots if changes are intentional: `npm run test -- -u`\n- Check for dynamic content that might change between runs\n```\n\n4. Create a test coverage report guide:\n```markdown\n# Test Coverage Guide\n\n## Coverage Goals\n\n- Statements: 80%+\n- Branches: 75%+\n- Functions: 80%+\n- Lines: 80%+\n\n## Generating Coverage Reports\n\n```bash\nnpm run test:coverage\n```\n\nThis will generate a coverage report in the `coverage` directory. Open `coverage/index.html` in your browser to view the detailed report.\n\n## Interpreting Coverage Reports\n\nThe coverage report shows:\n\n- **Statement Coverage**: Percentage of statements executed\n- **Branch Coverage**: Percentage of branches (if/else, switch cases) executed\n- **Function Coverage**: Percentage of functions called\n- **Line Coverage**: Percentage of lines executed\n\n## Improving Coverage\n\n1. Focus on critical paths first\n2. Look for uncovered branches in conditional logic\n3. Test error handling paths\n4. Add tests for edge cases\n\n## Coverage Exemptions\n\nSome files may be exempted from coverage requirements:\n\n- Third-party library wrappers\n- Configuration files\n- Test utilities\n\nTo exclude a file from coverage, add a comment:\n\n```js\n/* istanbul ignore file */\n```\n\nTo exclude a specific line or block:\n\n```js\n/* istanbul ignore next */\nif (process.env.NODE_ENV === 'development') {\n  // Development-only code\n}\n```\n```\n\n5. Create a troubleshooting guide:\n```markdown\n# Testing Troubleshooting Guide\n\n## Common Issues\n\n### MSW Not Intercepting API Calls\n\n**Symptoms**: Tests fail with actual API calls being made instead of being intercepted by MSW.\n\n**Solutions**:\n1. Verify that MSW server is started in the test setup\n2. Check that the request URL exactly matches the MSW handler pattern\n3. Ensure that the request method (GET, POST, etc.) matches\n\n### React Testing Library Queries Not Finding Elements\n\n**Symptoms**: `getBy*` queries throw errors or `queryBy*` returns null for elements that should exist.\n\n**Solutions**:\n1. Use `screen.debug()` to see the actual rendered HTML\n2. Try different queries (byRole, byText, byTestId)\n3. Check if elements are conditionally rendered\n4. Verify that components are properly mounted\n\n### Zustand Store Tests Not Working\n\n**Symptoms**: Store actions don't update state in tests or initial state is incorrect.\n\n**Solutions**:\n1. Create a fresh store instance for each test\n2. Reset mocks between tests\n3. Use the store's `getState()` method to access current state\n4. Verify that store actions are properly called\n\n### Playwright Tests Timing Out\n\n**Symptoms**: E2E tests fail with timeout errors.\n\n**Solutions**:\n1. Increase timeout in test configuration\n2. Use more specific selectors\n3. Add proper waiting conditions instead of fixed delays\n4. Check if the application is properly loaded\n5. Verify that the test server is running\n\n### Visual Regression Tests Failing\n\n**Symptoms**: Visual tests fail with screenshot mismatches.\n\n**Solutions**:\n1. Review the visual differences in the test report\n2. Update baselines if changes are intentional\n3. Check for dynamic content that might change between runs\n4. Adjust the comparison threshold for minor differences\n5. Use more specific selectors to target stable elements\n```",
        "testStrategy": "1. Create comprehensive documentation covering all testing aspects\n2. Develop clear guidelines for contributors to maintain consistency\n3. Document test running procedures for different test types\n4. Create troubleshooting guides for common issues\n5. Document coverage goals and reporting procedures\n6. Include examples and best practices for each test type\n7. Maintain up-to-date documentation as the testing strategy evolves\n8. Create a central testing documentation repository",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-09T02:22:40.302Z",
      "updated": "2025-11-09T02:22:40.302Z",
      "description": "Tasks for master context"
    }
  }
}