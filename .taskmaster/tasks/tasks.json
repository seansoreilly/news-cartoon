{
  "project": "news-cartoon",
  "version": "1.0.0",
  "description": "Regression Test Suite for News Cartoon Application",
  "tags": {
    "master": {
      "name": "master",
      "description": "Default tag",
      "createdAt": "2025-11-09T00:00:00.000Z",
      "tasks": []
    },
    "regression-tests": {
      "name": "regression-tests",
      "description": "Comprehensive regression test suite for news-cartoon application",
      "createdAt": "2025-11-09T00:00:00.000Z",
      "tasks": [
        {
          "id": "1",
          "title": "Set up comprehensive test infrastructure",
          "description": "Configure Vitest, React Testing Library, and test utilities for the project",
          "details": "- Configure Vitest in vite.config.ts with jsdom environment\n- Set up comprehensive test globals and mocks in src/test/setup.ts\n- Create shared test utilities and custom render functions\n- Configure code coverage with 80% threshold targets\n- Set up test data fixtures and factory functions\n- Add MSW (Mock Service Worker) for API mocking\n- Configure pre-commit hooks for test running",
          "testStrategy": "Run npm test to verify all configurations work. Generate coverage report and ensure it displays correctly.",
          "priority": "high",
          "status": "pending",
          "dependencies": [],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        },
        {
          "id": "2",
          "title": "Create unit tests for all service modules",
          "description": "Write comprehensive unit tests for newsService, geminiService, and locationService",
          "details": "- Test newsService: fetchNewsByLocation, fetchNewsByKeyword, caching, retry logic\n- Test geminiService: generateCartoonConcepts, generateComicScript, generateCartoonImage, caching\n- Test locationService: detectLocation, getLocationFromGPS, getLocationFromIP\n- Mock all external API calls and browser APIs\n- Test error handling, edge cases, and retry mechanisms\n- Achieve 90%+ coverage for service layer",
          "testStrategy": "Each service should have its own test file. Verify all public methods are tested with various scenarios.",
          "priority": "high",
          "status": "pending",
          "dependencies": [
            "1"
          ],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        },
        {
          "id": "3",
          "title": "Create unit tests for all Zustand stores",
          "description": "Write comprehensive tests for cartoonStore, newsStore, locationStore, and preferencesStore",
          "details": "- Test all store actions and state transitions\n- Test localStorage persistence and hydration\n- Test store reset functionality\n- Test computed values and selectors\n- Test error state management\n- Verify store isolation and independence",
          "testStrategy": "Create separate test files for each store. Use renderHook from React Testing Library to test store hooks.",
          "priority": "high",
          "status": "pending",
          "dependencies": [
            "1"
          ],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        },
        {
          "id": "4",
          "title": "Create component tests for all React components",
          "description": "Write comprehensive component tests using React Testing Library",
          "details": "- Test NewsDisplay component with various article states\n- Test ConceptGenerator with concept selection flow\n- Test ImageGenerator with rate limiting scenarios\n- Test LocationDetector with GPS and manual entry\n- Test Layout, ErrorBoundary, and navigation components\n- Test loading states, error states, and user interactions\n- Verify accessibility and ARIA attributes",
          "testStrategy": "Each component should have a corresponding .test.tsx file. Use userEvent for interactions.",
          "priority": "high",
          "status": "pending",
          "dependencies": [
            "1"
          ],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        },
        {
          "id": "5",
          "title": "Set up Playwright for E2E testing",
          "description": "Configure Playwright and create end-to-end tests for critical user journeys",
          "details": "- Install and configure Playwright with multiple browsers\n- Create E2E tests for location-based news flow\n- Test keyword search and article display\n- Test complete cartoon generation flow\n- Test rate limiting and error recovery\n- Test settings persistence across sessions\n- Set up visual regression testing\n- Configure parallel test execution",
          "testStrategy": "Run playwright test to verify all user flows work correctly across browsers.",
          "priority": "medium",
          "status": "pending",
          "dependencies": [
            "2",
            "3",
            "4"
          ],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        },
        {
          "id": "6",
          "title": "Create API and backend tests",
          "description": "Write comprehensive tests for the Express backend server",
          "details": "- Test /api/news/search endpoint with various queries\n- Test /api/article/content scraping functionality\n- Test RSS feed parsing from Google News\n- Test error handling and status codes\n- Test CORS configuration\n- Test request validation and sanitization\n- Test caching mechanisms\n- Use supertest for API testing",
          "testStrategy": "Run server tests separately with npm run test:server. Verify all endpoints handle edge cases.",
          "priority": "medium",
          "status": "pending",
          "dependencies": [
            "1"
          ],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        },
        {
          "id": "7",
          "title": "Set up CI/CD test automation",
          "description": "Configure GitHub Actions or similar CI/CD for automated testing",
          "details": "- Create workflow for running tests on pull requests\n- Set up test matrix for multiple Node versions\n- Configure code coverage reporting to Codecov or similar\n- Set up branch protection requiring passing tests\n- Configure performance budget checks\n- Add bundle size analysis\n- Set up automated dependency updates with tests",
          "testStrategy": "Push changes to trigger CI/CD pipeline. Verify all checks pass and reports generate.",
          "priority": "medium",
          "status": "pending",
          "dependencies": [
            "5",
            "6"
          ],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        },
        {
          "id": "8",
          "title": "Create testing documentation and guidelines",
          "description": "Document testing strategies, patterns, and best practices for the project",
          "details": "- Write comprehensive testing guide in docs/TESTING.md\n- Document test running commands and options\n- Create troubleshooting guide for common test issues\n- Document mocking strategies and patterns\n- Create examples of good test practices\n- Document coverage goals and how to improve them\n- Create contribution guidelines for test requirements",
          "testStrategy": "Review documentation with team. Ensure new contributors can understand and run tests.",
          "priority": "low",
          "status": "pending",
          "dependencies": [
            "7"
          ],
          "createdAt": "2025-11-09T00:00:00.000Z",
          "subtasks": []
        }
      ]
    }
  },
  "metadata": {
    "createdAt": "2025-11-09T00:00:00.000Z",
    "updatedAt": "2025-11-25T06:28:49.467Z",
    "currentTag": "regression-tests"
  },
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Testing Infrastructure and Configuration",
        "description": "Configure the testing environment with Vitest, React Testing Library, Playwright, and MSW. Set up the CI/CD pipeline integration for automated test runs.",
        "details": "1. Install required dependencies:\n```bash\nnpm install --save-dev vitest @testing-library/react @testing-library/user-event @testing-library/jest-dom msw playwright\n```\n\n2. Configure Vitest for unit and integration tests:\n```javascript\n// vitest.config.js\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: './src/test/setup.js',\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n      statements: 80,\n      branches: 75,\n      functions: 80,\n      lines: 80\n    },\n  },\n})\n```\n\n3. Create test setup file:\n```javascript\n// src/test/setup.js\nimport '@testing-library/jest-dom'\nimport { server } from './mocks/server'\n\nbeforeAll(() => server.listen())\nafterEach(() => server.resetHandlers())\nafterAll(() => server.close())\n```\n\n4. Configure MSW for API mocking:\n```javascript\n// src/test/mocks/server.js\nimport { setupServer } from 'msw/node'\nimport { handlers } from './handlers'\n\nexport const server = setupServer(...handlers)\n```\n\n5. Set up Playwright for E2E testing:\n```bash\nnpx playwright install\n```\n\n6. Create Playwright configuration:\n```javascript\n// playwright.config.js\nexport default {\n  testDir: './e2e',\n  timeout: 30000,\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n  },\n  projects: [\n    { name: 'chromium', use: { browserName: 'chromium' } },\n    { name: 'firefox', use: { browserName: 'firefox' } },\n    { name: 'webkit', use: { browserName: 'webkit' } },\n    { name: 'mobile', use: { browserName: 'chromium', viewport: { width: 390, height: 844 } } }\n  ],\n}\n```\n\n7. Configure CI/CD pipeline (GitHub Actions example):\n```yaml\n# .github/workflows/test.yml\nname: Test Suite\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18\n      - run: npm ci\n      - run: npm run test:unit\n      - run: npm run test:e2e\n      - name: Upload coverage reports\n        uses: codecov/codecov-action@v3\n```\n\n8. Add scripts to package.json:\n```json\n{\n  \"scripts\": {\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"test:coverage\": \"vitest run --coverage\",\n    \"test:e2e\": \"playwright test\",\n    \"test:ci\": \"npm run test && npm run test:e2e\"\n  }\n}\n```\n\n9. Set up pre-commit hooks with Husky:\n```bash\nnpm install --save-dev husky lint-staged\nnpx husky install\nnpx husky add .husky/pre-commit \"npx lint-staged\"\n```\n\n10. Configure lint-staged in package.json:\n```json\n{\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": [\"eslint --fix\", \"vitest related --run\"]\n  }\n}\n```",
        "testStrategy": "1. Verify that all testing tools are correctly installed and configured by running sample tests for each type (unit, component, integration, E2E).\n2. Validate CI/CD pipeline configuration by pushing a test commit and confirming that tests run automatically.\n3. Check that coverage reporting is working by running the coverage command and verifying the output report.\n4. Test pre-commit hooks by making changes and attempting to commit them.\n5. Verify that the testing environment correctly mocks external dependencies by writing a simple test that uses MSW to intercept API calls.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Testing Libraries",
            "description": "Install all required testing dependencies and create basic configuration files for Vitest, React Testing Library, and MSW.",
            "dependencies": [],
            "details": "Run npm install to add all testing dependencies. Create the vitest.config.js file with proper configuration for React components testing. Set up the test setup file that includes jest-dom extensions and MSW server initialization. Create the initial MSW server configuration file structure.",
            "status": "done",
            "testStrategy": "Verify successful installation by running a simple test command and checking that the environment is properly configured."
          },
          {
            "id": 2,
            "title": "Set Up Mock Service Worker for API Mocking",
            "description": "Configure MSW handlers and server for mocking API responses in tests.",
            "dependencies": [],
            "details": "Create the handlers.js file with mock implementations for all API endpoints used in the application. Set up the MSW server configuration to use these handlers. Implement request handlers for news API, Gemini API, and location services. Create sample response fixtures that match the expected API response structure.",
            "status": "done",
            "testStrategy": "Create a simple test that uses MSW to verify API mocking is working correctly."
          },
          {
            "id": 3,
            "title": "Configure Playwright for E2E Testing",
            "description": "Set up Playwright for end-to-end testing with multi-browser and mobile viewport support.",
            "dependencies": [],
            "details": "Install Playwright browsers using npx playwright install. Create the playwright.config.js file with configuration for multiple browsers (Chrome, Firefox, Safari) and mobile viewport. Set up test fixtures and helper functions for common E2E testing patterns. Configure screenshot and trace capturing for test failures.",
            "status": "done",
            "testStrategy": "Run a simple Playwright test against a static page to verify the E2E setup is working correctly across browsers."
          },
          {
            "id": 4,
            "title": "Set Up CI/CD Pipeline Integration",
            "description": "Configure GitHub Actions workflow for automated test execution on push and pull requests.",
            "dependencies": [],
            "details": "Create the GitHub Actions workflow file (.github/workflows/test.yml) that runs unit, integration, and E2E tests. Configure the workflow to upload test coverage reports to Codecov. Set up caching for node_modules to improve CI performance. Configure the workflow to run tests in parallel where possible.",
            "status": "done",
            "testStrategy": "Push a test commit to verify that the GitHub Actions workflow runs successfully and reports test results correctly."
          },
          {
            "id": 5,
            "title": "Implement Pre-commit Hooks and Documentation",
            "description": "Set up Husky and lint-staged for pre-commit test validation, and document the testing infrastructure.",
            "dependencies": [],
            "details": "Install and configure Husky for git hooks. Set up lint-staged to run relevant tests on staged files before commit. Add test scripts to package.json for different test types (unit, e2e, coverage). Create a TESTING.md file documenting the testing strategy, tools, and patterns used in the project. Include examples of how to write tests for components, services, and stores.",
            "status": "done",
            "testStrategy": "Make a test commit with both passing and failing tests to verify that pre-commit hooks correctly prevent commits with failing tests."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Unit Tests for Services and Stores",
        "description": "Create comprehensive unit tests for all service modules (newsService, geminiService, locationService) and Zustand stores (cartoonStore, newsStore, locationStore, preferencesStore) with proper mocking of external dependencies.",
        "details": "1. Create test files for each service:\n```javascript\n// src/services/__tests__/newsService.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { fetchNews, parseArticle } from '../newsService'\nimport { rest } from 'msw'\nimport { server } from '../../test/mocks/server'\n\ndescribe('newsService', () => {\n  beforeEach(() => {\n    vi.resetAllMocks()\n  })\n\n  it('fetches news successfully', async () => {\n    // Mock successful API response\n    server.use(\n      rest.get('/api/news/search', (req, res, ctx) => {\n        return res(ctx.json({ articles: [{ id: 1, title: 'Test Article' }] }))\n      })\n    )\n\n    const result = await fetchNews('test location')\n    expect(result.articles).toHaveLength(1)\n    expect(result.articles[0].title).toBe('Test Article')\n  })\n\n  it('handles API errors gracefully', async () => {\n    // Mock API error\n    server.use(\n      rest.get('/api/news/search', (req, res, ctx) => {\n        return res(ctx.status(500))\n      })\n    )\n\n    await expect(fetchNews('test location')).rejects.toThrow()\n  })\n\n  // Additional tests for other functions\n})\n```\n\n2. Create similar test files for geminiService and locationService.\n\n3. Test Zustand stores:\n```javascript\n// src/stores/__tests__/cartoonStore.test.js\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { createCartoonStore } from '../cartoonStore'\nimport { act, renderHook } from '@testing-library/react'\nimport * as geminiService from '../../services/geminiService'\n\n// Mock the geminiService\nvi.mock('../../services/geminiService', () => ({\n  generateCartoonConcept: vi.fn(),\n  generateImage: vi.fn()\n}))\n\ndescribe('cartoonStore', () => {\n  beforeEach(() => {\n    vi.resetAllMocks()\n  })\n\n  it('initializes with default state', () => {\n    const { result } = renderHook(() => createCartoonStore())\n    \n    expect(result.current.cartoon).toBeNull()\n    expect(result.current.isLoading).toBe(false)\n    expect(result.current.error).toBeNull()\n  })\n\n  it('generates cartoon concept successfully', async () => {\n    // Mock successful concept generation\n    geminiService.generateCartoonConcept.mockResolvedValue('Funny concept')\n    \n    const { result } = renderHook(() => createCartoonStore())\n    \n    await act(async () => {\n      await result.current.generateConcept('Test article')\n    })\n    \n    expect(geminiService.generateCartoonConcept).toHaveBeenCalledWith('Test article')\n    expect(result.current.concept).toBe('Funny concept')\n    expect(result.current.isLoading).toBe(false)\n  })\n\n  it('handles errors during concept generation', async () => {\n    // Mock error\n    geminiService.generateCartoonConcept.mockRejectedValue(new Error('API error'))\n    \n    const { result } = renderHook(() => createCartoonStore())\n    \n    await act(async () => {\n      await result.current.generateConcept('Test article')\n    })\n    \n    expect(result.current.error).toBeTruthy()\n    expect(result.current.isLoading).toBe(false)\n  })\n\n  // Additional tests for other actions\n})\n```\n\n4. Create similar test files for newsStore, locationStore, and preferencesStore.\n\n5. Test utility functions:\n```javascript\n// src/utils/__tests__/errorHandler.test.js\nimport { describe, it, expect, vi } from 'vitest'\nimport { handleApiError, logError } from '../errorHandler'\n\ndescribe('errorHandler', () => {\n  it('formats API errors correctly', () => {\n    const error = new Error('Network error')\n    error.response = { status: 404, data: { message: 'Not found' } }\n    \n    const result = handleApiError(error)\n    \n    expect(result).toEqual({\n      message: 'Not found',\n      status: 404,\n      isApiError: true\n    })\n  })\n\n  it('handles non-API errors', () => {\n    const error = new Error('Generic error')\n    \n    const result = handleApiError(error)\n    \n    expect(result).toEqual({\n      message: 'Generic error',\n      status: 500,\n      isApiError: false\n    })\n  })\n\n  // Additional tests\n})\n```\n\n6. Create similar test files for rateLimiter and cache utilities.\n\n7. Test edge cases and error handling for all services and stores:\n   - Empty responses\n   - Malformed data\n   - Network timeouts\n   - Rate limiting scenarios\n   - Cache hits and misses",
        "testStrategy": "1. Use Vitest's mocking capabilities to isolate units under test from external dependencies.\n2. Test both success and failure paths for all functions.\n3. Verify that stores correctly manage state transitions (loading, success, error states).\n4. Use MSW to mock API responses for service tests.\n5. Test edge cases such as empty data, malformed responses, and error conditions.\n6. Validate that error handling works as expected across all modules.\n7. Ensure rate limiting and caching utilities function correctly under various scenarios.\n8. Run tests in isolation and verify they don't have side effects on other tests.\n9. Aim for 80%+ code coverage for all tested modules.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Unit Tests for News Service",
            "description": "Create comprehensive unit tests for the newsService module, covering all functions including fetchNews and parseArticle. Test both success and error scenarios with proper mocking of external dependencies.",
            "dependencies": [],
            "details": "Create test file at src/services/__tests__/newsService.test.js. Use MSW to mock API responses. Test successful API calls, error handling, edge cases like empty responses, and utility functions. Ensure all exported functions are covered with tests for different input scenarios. Mock the fetch API and test rate limiting behavior.",
            "status": "pending",
            "testStrategy": "Use MSW to intercept and mock API calls. Test both success and error paths. Verify correct parsing of different response formats. Test edge cases like malformed data and network timeouts."
          },
          {
            "id": 2,
            "title": "Implement Unit Tests for Gemini and Location Services",
            "description": "Create unit tests for geminiService (AI generation) and locationService modules, ensuring all functions are tested with proper mocking of external dependencies.",
            "dependencies": [],
            "details": "Create test files at src/services/__tests__/geminiService.test.js and src/services/__tests__/locationService.test.js. Mock API responses for both services. For geminiService, test image generation, concept creation, and error handling. For locationService, test geolocation fetching, address parsing, and caching mechanisms. Ensure proper error handling tests for API failures.",
            "status": "pending",
            "testStrategy": "Mock external API calls using MSW or vi.mock. Test rate limiting, caching behavior, and error recovery strategies. Verify that services handle malformed responses gracefully."
          },
          {
            "id": 3,
            "title": "Implement Unit Tests for Cartoon and News Stores",
            "description": "Create unit tests for the Zustand stores cartoonStore and newsStore, verifying state management, actions, and integration with their respective services.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Create test files at src/stores/__tests__/cartoonStore.test.js and src/stores/__tests__/newsStore.test.js. Use renderHook from @testing-library/react to test store hooks. Mock the geminiService and newsService dependencies. Test initial state, state transitions during loading/success/error, and all store actions. Verify that stores correctly handle service responses and errors.",
            "status": "pending",
            "testStrategy": "Mock service dependencies using vi.mock. Test state transitions through all possible flows. Verify that loading states, error handling, and success scenarios work correctly. Test store selectors and derived state."
          },
          {
            "id": 4,
            "title": "Implement Unit Tests for Location and Preferences Stores",
            "description": "Create unit tests for the locationStore and preferencesStore Zustand stores, verifying state management, persistence, and integration with services.",
            "dependencies": [
              "2.2"
            ],
            "details": "Create test files at src/stores/__tests__/locationStore.test.js and src/stores/__tests__/preferencesStore.test.js. Test initial state loading, state persistence to localStorage, and all store actions. For locationStore, mock the locationService and test location fetching, caching, and error handling. For preferencesStore, test theme switching, preference saving, and default values.",
            "status": "pending",
            "testStrategy": "Mock localStorage access to test persistence. Test that stores correctly load initial state from storage. Verify that all actions correctly update state and trigger side effects like storage updates."
          },
          {
            "id": 5,
            "title": "Implement Unit Tests for Utility Functions",
            "description": "Create unit tests for all utility functions including error handlers, rate limiters, and caching utilities, ensuring they work correctly in isolation.",
            "dependencies": [],
            "details": "Create test files for each utility module (e.g., src/utils/__tests__/errorHandler.test.js, src/utils/__tests__/rateLimiter.test.js, src/utils/__tests__/cache.test.js). Test error formatting, logging, rate limiting behavior with different configurations, and cache hit/miss scenarios. Verify that utilities handle edge cases correctly.",
            "status": "pending",
            "testStrategy": "Test utilities in isolation with various input scenarios. For time-based utilities like rate limiters, use vi.useFakeTimers() to control time. Test cache expiration, eviction policies, and storage limits."
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop Component and Integration Tests",
        "description": "Create tests for all React components in isolation and test their integration with stores and services. Validate component props, state, interactions, accessibility, and responsive behavior.",
        "details": "1. Create component tests for UI elements:\n```javascript\n// src/components/__tests__/NewsCard.test.jsx\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport NewsCard from '../NewsCard'\n\ndescribe('NewsCard', () => {\n  const mockArticle = {\n    id: '123',\n    title: 'Test Headline',\n    description: 'Test description',\n    source: { name: 'Test Source' },\n    publishedAt: '2023-01-01T12:00:00Z'\n  }\n\n  it('renders article information correctly', () => {\n    render(<NewsCard article={mockArticle} />)\n    \n    expect(screen.getByText('Test Headline')).toBeInTheDocument()\n    expect(screen.getByText('Test description')).toBeInTheDocument()\n    expect(screen.getByText('Test Source')).toBeInTheDocument()\n    expect(screen.getByText(/Jan 1, 2023/)).toBeInTheDocument()\n  })\n\n  it('calls onSelect when clicked', async () => {\n    const user = userEvent.setup()\n    const mockOnSelect = vi.fn()\n    \n    render(<NewsCard article={mockArticle} onSelect={mockOnSelect} />)\n    \n    await user.click(screen.getByRole('article'))\n    \n    expect(mockOnSelect).toHaveBeenCalledWith(mockArticle)\n  })\n\n  it('displays loading state correctly', () => {\n    render(<NewsCard isLoading={true} />)\n    \n    expect(screen.getByTestId('news-card-skeleton')).toBeInTheDocument()\n  })\n\n  it('is accessible', () => {\n    const { container } = render(<NewsCard article={mockArticle} />)\n    \n    expect(container).toBeAccessible()\n  })\n})\n```\n\n2. Test more complex components with state:\n```javascript\n// src/components/__tests__/CartoonGenerator.test.jsx\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport CartoonGenerator from '../CartoonGenerator'\nimport { useCartoonStore } from '../../stores/cartoonStore'\n\n// Mock the store\nvi.mock('../../stores/cartoonStore', () => ({\n  useCartoonStore: vi.fn()\n}))\n\ndescribe('CartoonGenerator', () => {\n  const mockGenerateConcept = vi.fn()\n  const mockGenerateImage = vi.fn()\n  \n  beforeEach(() => {\n    useCartoonStore.mockReturnValue({\n      concept: null,\n      image: null,\n      isLoading: false,\n      error: null,\n      generateConcept: mockGenerateConcept,\n      generateImage: mockGenerateImage\n    })\n  })\n\n  it('renders the initial state correctly', () => {\n    render(<CartoonGenerator article={{ title: 'Test Article', content: 'Test content' }} />)\n    \n    expect(screen.getByText('Generate Cartoon')).toBeInTheDocument()\n  })\n\n  it('generates concept when button is clicked', async () => {\n    const user = userEvent.setup()\n    render(<CartoonGenerator article={{ title: 'Test Article', content: 'Test content' }} />)\n    \n    await user.click(screen.getByText('Generate Cartoon'))\n    \n    expect(mockGenerateConcept).toHaveBeenCalledWith({ title: 'Test Article', content: 'Test content' })\n  })\n\n  it('displays loading state', () => {\n    useCartoonStore.mockReturnValue({\n      concept: null,\n      image: null,\n      isLoading: true,\n      error: null,\n      generateConcept: mockGenerateConcept,\n      generateImage: mockGenerateImage\n    })\n    \n    render(<CartoonGenerator article={{ title: 'Test Article', content: 'Test content' }} />)\n    \n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()\n  })\n\n  it('displays generated concept and allows image generation', async () => {\n    const user = userEvent.setup()\n    useCartoonStore.mockReturnValue({\n      concept: 'Funny cartoon concept',\n      image: null,\n      isLoading: false,\n      error: null,\n      generateConcept: mockGenerateConcept,\n      generateImage: mockGenerateImage\n    })\n    \n    render(<CartoonGenerator article={{ title: 'Test Article', content: 'Test content' }} />)\n    \n    expect(screen.getByText('Funny cartoon concept')).toBeInTheDocument()\n    \n    await user.click(screen.getByText('Generate Image'))\n    \n    expect(mockGenerateImage).toHaveBeenCalledWith('Funny cartoon concept')\n  })\n\n  it('displays error state', () => {\n    useCartoonStore.mockReturnValue({\n      concept: null,\n      image: null,\n      isLoading: false,\n      error: 'Failed to generate concept',\n      generateConcept: mockGenerateConcept,\n      generateImage: mockGenerateImage\n    })\n    \n    render(<CartoonGenerator article={{ title: 'Test Article', content: 'Test content' }} />)\n    \n    expect(screen.getByText('Failed to generate concept')).toBeInTheDocument()\n  })\n})\n```\n\n3. Create integration tests for component-store interactions:\n```javascript\n// src/integration/__tests__/NewsFlow.test.jsx\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { rest } from 'msw'\nimport { server } from '../../test/mocks/server'\nimport NewsPage from '../../pages/NewsPage'\n\ndescribe('News Flow Integration', () => {\n  beforeEach(() => {\n    // Mock location API\n    server.use(\n      rest.get('/api/location', (req, res, ctx) => {\n        return res(ctx.json({ city: 'New York', country: 'US' }))\n      }),\n      rest.get('/api/news/search', (req, res, ctx) => {\n        return res(ctx.json({\n          articles: [\n            { id: '1', title: 'Test Article 1', description: 'Description 1' },\n            { id: '2', title: 'Test Article 2', description: 'Description 2' }\n          ]\n        }))\n      }),\n      rest.get('/api/article/content', (req, res, ctx) => {\n        return res(ctx.json({ content: 'Full article content' }))\n      })\n    )\n  })\n\n  it('loads news based on detected location', async () => {\n    render(<NewsPage />)\n    \n    // Wait for location detection and news loading\n    await waitFor(() => {\n      expect(screen.getByText('News for New York, US')).toBeInTheDocument()\n    })\n    \n    // Verify articles are displayed\n    expect(screen.getByText('Test Article 1')).toBeInTheDocument()\n    expect(screen.getByText('Test Article 2')).toBeInTheDocument()\n  })\n\n  it('allows selecting an article to view details', async () => {\n    const user = userEvent.setup()\n    render(<NewsPage />)\n    \n    // Wait for news to load\n    await waitFor(() => {\n      expect(screen.getByText('Test Article 1')).toBeInTheDocument()\n    })\n    \n    // Click on an article\n    await user.click(screen.getByText('Test Article 1'))\n    \n    // Verify article content loads\n    await waitFor(() => {\n      expect(screen.getByText('Full article content')).toBeInTheDocument()\n    })\n  })\n\n  it('allows changing location manually', async () => {\n    const user = userEvent.setup()\n    \n    // Mock the API for the new location\n    server.use(\n      rest.get('/api/news/search', (req, res, ctx) => {\n        const location = req.url.searchParams.get('location')\n        if (location === 'London') {\n          return res(ctx.json({\n            articles: [{ id: '3', title: 'London News', description: 'News from London' }]\n          }))\n        }\n        return res(ctx.json({ articles: [] }))\n      })\n    )\n    \n    render(<NewsPage />)\n    \n    // Wait for initial news to load\n    await waitFor(() => {\n      expect(screen.getByText('News for New York, US')).toBeInTheDocument()\n    })\n    \n    // Change location\n    await user.click(screen.getByLabelText('Change location'))\n    await user.type(screen.getByRole('textbox'), 'London')\n    await user.click(screen.getByText('Search'))\n    \n    // Verify new location news loads\n    await waitFor(() => {\n      expect(screen.getByText('London News')).toBeInTheDocument()\n    })\n  })\n})\n```\n\n4. Test responsive behavior:\n```javascript\n// src/components/__tests__/ResponsiveLayout.test.jsx\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport ResponsiveLayout from '../ResponsiveLayout'\n\ndescribe('ResponsiveLayout', () => {\n  it('applies mobile class on small viewport', () => {\n    // Mock small viewport\n    window.innerWidth = 480\n    window.dispatchEvent(new Event('resize'))\n    \n    const { container } = render(<ResponsiveLayout><div>Content</div></ResponsiveLayout>)\n    \n    expect(container.firstChild).toHaveClass('mobile-layout')\n  })\n\n  it('applies desktop class on large viewport', () => {\n    // Mock large viewport\n    window.innerWidth = 1200\n    window.dispatchEvent(new Event('resize'))\n    \n    const { container } = render(<ResponsiveLayout><div>Content</div></ResponsiveLayout>)\n    \n    expect(container.firstChild).toHaveClass('desktop-layout')\n  })\n})\n```\n\n5. Test accessibility features:\n```javascript\n// src/components/__tests__/Accessibility.test.jsx\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport NavigationMenu from '../NavigationMenu'\n\ndescribe('Accessibility', () => {\n  it('supports keyboard navigation', async () => {\n    const user = userEvent.setup()\n    render(<NavigationMenu items={[\n      { id: 1, label: 'Home' },\n      { id: 2, label: 'News' },\n      { id: 3, label: 'Settings' }\n    ]} />)\n    \n    // Tab to first menu item\n    await user.tab()\n    expect(screen.getByText('Home')).toHaveFocus()\n    \n    // Tab to second menu item\n    await user.tab()\n    expect(screen.getByText('News')).toHaveFocus()\n    \n    // Tab to third menu item\n    await user.tab()\n    expect(screen.getByText('Settings')).toHaveFocus()\n  })\n\n  it('has proper ARIA attributes', () => {\n    render(<NavigationMenu items={[\n      { id: 1, label: 'Home' },\n      { id: 2, label: 'News' },\n      { id: 3, label: 'Settings' }\n    ]} />)\n    \n    const nav = screen.getByRole('navigation')\n    expect(nav).toHaveAttribute('aria-label', 'Main Navigation')\n    \n    const menuItems = screen.getAllByRole('menuitem')\n    expect(menuItems).toHaveLength(3)\n    menuItems.forEach(item => {\n      expect(item).toHaveAttribute('aria-label')\n    })\n  })\n})\n```",
        "testStrategy": "1. Use React Testing Library to test components in isolation, focusing on user interactions rather than implementation details.\n2. Test all component states: loading, error, success, and empty states.\n3. Verify that components correctly respond to props and user interactions.\n4. Test accessibility features using jest-axe or similar tools.\n5. Test responsive behavior by mocking different viewport sizes.\n6. For integration tests, use MSW to mock API responses and test complete user flows.\n7. Verify that components correctly integrate with stores and services.\n8. Test error handling and recovery flows.\n9. Ensure all critical user paths are covered in integration tests.\n10. Validate that components meet accessibility standards (WCAG 2.1 AA).",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Component Tests for UI Elements",
            "description": "Implement unit tests for simple UI components focusing on rendering, props validation, and basic interactions. Test components in isolation to verify they render correctly with different props and respond appropriately to user interactions.",
            "dependencies": [],
            "details": "Create test files for basic UI components like NewsCard, Button, and other simple UI elements. Use React Testing Library to test component rendering, prop validation, and user interactions. Focus on testing component behavior from a user perspective rather than implementation details. Include tests for different component states (default, loading, error) and verify accessibility compliance.\n\nExample implementation:\n```javascript\n// src/components/__tests__/Button.test.jsx\nimport { describe, it, expect } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport Button from '../Button'\n\ndescribe('Button', () => {\n  it('renders with correct text', () => {\n    render(<Button>Click me</Button>)\n    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument()\n  })\n\n  it('calls onClick handler when clicked', async () => {\n    const user = userEvent.setup()\n    const handleClick = vi.fn()\n    \n    render(<Button onClick={handleClick}>Click me</Button>)\n    await user.click(screen.getByRole('button'))\n    \n    expect(handleClick).toHaveBeenCalledTimes(1)\n  })\n\n  it('renders in disabled state when disabled prop is true', () => {\n    render(<Button disabled>Click me</Button>)\n    expect(screen.getByRole('button')).toBeDisabled()\n  })\n\n  it('applies variant classes correctly', () => {\n    const { rerender } = render(<Button variant=\"primary\">Button</Button>)\n    expect(screen.getByRole('button')).toHaveClass('btn-primary')\n    \n    rerender(<Button variant=\"secondary\">Button</Button>)\n    expect(screen.getByRole('button')).toHaveClass('btn-secondary')\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Use React Testing Library to focus on user-centric testing. Test component rendering, props validation, and user interactions. Include tests for different component states and accessibility compliance. Use mock functions to verify event handlers are called correctly."
          },
          {
            "id": 2,
            "title": "Implement Tests for Stateful Components",
            "description": "Create comprehensive tests for complex components that manage state, handle user interactions, and integrate with stores. Test component lifecycle, state transitions, and error handling.",
            "dependencies": [
              "3.1"
            ],
            "details": "Develop tests for complex components like NewsFilter, ArticleViewer, and CartoonGenerator that manage internal state and integrate with stores. Mock store dependencies to isolate component behavior. Test component lifecycle methods, state transitions, and error handling. Verify that components correctly respond to store updates and user interactions.\n\nExample implementation:\n```javascript\n// src/components/__tests__/NewsFilter.test.jsx\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport NewsFilter from '../NewsFilter'\nimport { useNewsStore } from '../../stores/newsStore'\n\n// Mock the store\nvi.mock('../../stores/newsStore', () => ({\n  useNewsStore: vi.fn()\n}))\n\ndescribe('NewsFilter', () => {\n  const mockSetCategory = vi.fn()\n  const mockSetSearchTerm = vi.fn()\n  \n  beforeEach(() => {\n    useNewsStore.mockReturnValue({\n      categories: ['business', 'technology', 'sports'],\n      selectedCategory: 'business',\n      searchTerm: '',\n      setCategory: mockSetCategory,\n      setSearchTerm: mockSetSearchTerm\n    })\n  })\n\n  it('renders all available categories', () => {\n    render(<NewsFilter />)\n    \n    expect(screen.getByRole('button', { name: /business/i })).toBeInTheDocument()\n    expect(screen.getByRole('button', { name: /technology/i })).toBeInTheDocument()\n    expect(screen.getByRole('button', { name: /sports/i })).toBeInTheDocument()\n  })\n\n  it('highlights the selected category', () => {\n    render(<NewsFilter />)\n    \n    const businessButton = screen.getByRole('button', { name: /business/i })\n    expect(businessButton).toHaveClass('selected')\n  })\n\n  it('calls setCategory when a category is clicked', async () => {\n    const user = userEvent.setup()\n    render(<NewsFilter />)\n    \n    await user.click(screen.getByRole('button', { name: /technology/i }))\n    \n    expect(mockSetCategory).toHaveBeenCalledWith('technology')\n  })\n\n  it('updates search term on input change', async () => {\n    const user = userEvent.setup()\n    render(<NewsFilter />)\n    \n    await user.type(screen.getByRole('searchbox'), 'climate')\n    \n    expect(mockSetSearchTerm).toHaveBeenCalledWith('climate')\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Mock store dependencies to isolate component behavior. Test component lifecycle methods, state transitions, and error handling. Verify that components correctly respond to store updates and user interactions. Test both success and error paths."
          },
          {
            "id": 3,
            "title": "Create Integration Tests for Component-Store Interactions",
            "description": "Develop integration tests that verify the correct interaction between components and stores. Test data flow, state management, and component updates in response to store changes.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Create integration tests that verify components correctly interact with stores. Test data flow between components and stores, state management, and component updates in response to store changes. Use MSW to mock API responses and test the full interaction flow from user action to UI update.\n\nExample implementation:\n```javascript\n// src/integration/__tests__/NewsListIntegration.test.jsx\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { rest } from 'msw'\nimport { server } from '../../test/mocks/server'\nimport NewsList from '../../components/NewsList'\n\ndescribe('NewsList Integration', () => {\n  beforeEach(() => {\n    // Reset any runtime handlers\n    server.resetHandlers()\n    \n    // Mock the news API endpoint\n    server.use(\n      rest.get('/api/news', (req, res, ctx) => {\n        const category = req.url.searchParams.get('category')\n        \n        if (category === 'technology') {\n          return res(ctx.json({\n            articles: [\n              { id: '1', title: 'Tech News 1', description: 'Description 1' },\n              { id: '2', title: 'Tech News 2', description: 'Description 2' }\n            ]\n          }))\n        }\n        \n        return res(ctx.json({\n          articles: [\n            { id: '3', title: 'Business News 1', description: 'Description 3' },\n            { id: '4', title: 'Business News 2', description: 'Description 4' }\n          ]\n        }))\n      })\n    )\n  })\n\n  it('loads and displays news articles', async () => {\n    render(<NewsList />)\n    \n    // Wait for articles to load\n    await waitFor(() => {\n      expect(screen.getByText('Business News 1')).toBeInTheDocument()\n    })\n    \n    expect(screen.getByText('Business News 2')).toBeInTheDocument()\n  })\n\n  it('updates articles when category changes', async () => {\n    const user = userEvent.setup()\n    render(<NewsList />)\n    \n    // Wait for initial articles to load\n    await waitFor(() => {\n      expect(screen.getByText('Business News 1')).toBeInTheDocument()\n    })\n    \n    // Change category\n    await user.click(screen.getByRole('button', { name: /technology/i }))\n    \n    // Wait for new articles to load\n    await waitFor(() => {\n      expect(screen.getByText('Tech News 1')).toBeInTheDocument()\n    })\n    \n    expect(screen.getByText('Tech News 2')).toBeInTheDocument()\n    expect(screen.queryByText('Business News 1')).not.toBeInTheDocument()\n  })\n\n  it('displays loading state while fetching articles', async () => {\n    // Mock a delayed response\n    server.use(\n      rest.get('/api/news', (req, res, ctx) => {\n        return res(ctx.delay(300), ctx.json({\n          articles: [{ id: '1', title: 'Delayed News', description: 'Description' }]\n        }))\n      })\n    )\n    \n    render(<NewsList />)\n    \n    // Check for loading state\n    expect(screen.getByTestId('loading-indicator')).toBeInTheDocument()\n    \n    // Wait for articles to load\n    await waitFor(() => {\n      expect(screen.getByText('Delayed News')).toBeInTheDocument()\n    })\n    \n    // Loading indicator should be gone\n    expect(screen.queryByTestId('loading-indicator')).not.toBeInTheDocument()\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Use MSW to mock API responses and test the full interaction flow from user action to UI update. Test loading states, error states, and successful data fetching. Verify that components correctly update in response to store changes. Focus on testing user flows rather than implementation details."
          },
          {
            "id": 4,
            "title": "Implement Responsive Design and Accessibility Tests",
            "description": "Create tests that verify components behave correctly across different viewport sizes and meet accessibility standards. Test keyboard navigation, screen reader compatibility, and responsive layout changes.",
            "dependencies": [
              "3.1"
            ],
            "details": "Develop tests that verify components render correctly at different viewport sizes and meet accessibility standards. Test keyboard navigation, screen reader compatibility, and responsive layout changes. Use testing-library's accessibility utilities to check for common accessibility issues.\n\nExample implementation:\n```javascript\n// src/components/__tests__/ResponsiveNavigation.test.jsx\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport ResponsiveNavigation from '../ResponsiveNavigation'\n\ndescribe('ResponsiveNavigation', () => {\n  let originalInnerWidth\n  \n  beforeEach(() => {\n    originalInnerWidth = window.innerWidth\n    vi.spyOn(window, 'matchMedia')\n  })\n  \n  afterEach(() => {\n    window.innerWidth = originalInnerWidth\n    vi.restoreAllMocks()\n  })\n  \n  it('displays full navigation on desktop', () => {\n    // Mock desktop viewport\n    window.matchMedia.mockImplementation(query => ({\n      matches: query.includes('(min-width: 768px)'),\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn()\n    }))\n    \n    render(<ResponsiveNavigation />)\n    \n    // All nav items should be visible\n    expect(screen.getByText('Home')).toBeVisible()\n    expect(screen.getByText('News')).toBeVisible()\n    expect(screen.getByText('Settings')).toBeVisible()\n    \n    // Hamburger menu should not be visible\n    expect(screen.queryByLabelText('Open menu')).not.toBeInTheDocument()\n  })\n  \n  it('displays hamburger menu on mobile', () => {\n    // Mock mobile viewport\n    window.matchMedia.mockImplementation(query => ({\n      matches: !query.includes('(min-width: 768px)'),\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn()\n    }))\n    \n    render(<ResponsiveNavigation />)\n    \n    // Nav items should be hidden initially\n    expect(screen.queryByText('Home')).not.toBeVisible()\n    expect(screen.queryByText('News')).not.toBeVisible()\n    expect(screen.queryByText('Settings')).not.toBeVisible()\n    \n    // Hamburger menu should be visible\n    expect(screen.getByLabelText('Open menu')).toBeInTheDocument()\n  })\n  \n  it('opens mobile menu when hamburger is clicked', async () => {\n    const user = userEvent.setup()\n    \n    // Mock mobile viewport\n    window.matchMedia.mockImplementation(query => ({\n      matches: !query.includes('(min-width: 768px)'),\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn()\n    }))\n    \n    render(<ResponsiveNavigation />)\n    \n    // Click hamburger menu\n    await user.click(screen.getByLabelText('Open menu'))\n    \n    // Nav items should now be visible\n    expect(screen.getByText('Home')).toBeVisible()\n    expect(screen.getByText('News')).toBeVisible()\n    expect(screen.getByText('Settings')).toBeVisible()\n  })\n  \n  it('supports keyboard navigation', async () => {\n    const user = userEvent.setup()\n    render(<ResponsiveNavigation />)\n    \n    // Tab to first nav item\n    await user.tab()\n    expect(screen.getByText('Home')).toHaveFocus()\n    \n    // Tab to second nav item\n    await user.tab()\n    expect(screen.getByText('News')).toHaveFocus()\n    \n    // Tab to third nav item\n    await user.tab()\n    expect(screen.getByText('Settings')).toHaveFocus()\n  })\n  \n  it('has proper ARIA attributes', () => {\n    render(<ResponsiveNavigation />)\n    \n    const nav = screen.getByRole('navigation')\n    expect(nav).toHaveAttribute('aria-label', 'Main Navigation')\n    \n    const links = screen.getAllByRole('link')\n    links.forEach(link => {\n      expect(link).toHaveAttribute('aria-label')\n    })\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Mock different viewport sizes to test responsive behavior. Use testing-library's accessibility utilities to check for common accessibility issues. Test keyboard navigation to ensure the application is usable without a mouse. Verify that ARIA attributes are correctly applied to elements."
          },
          {
            "id": 5,
            "title": "Create Mock Service Worker Setup for API Testing",
            "description": "Set up Mock Service Worker (MSW) to intercept and mock API requests in tests. Create handlers for all API endpoints used by components and implement test scenarios for success, error, and loading states.",
            "dependencies": [],
            "details": "Set up Mock Service Worker (MSW) to intercept and mock API requests in tests. Create handlers for all API endpoints used by components and implement test scenarios for success, error, and loading states. This will allow testing components that make API calls without hitting actual endpoints.\n\nExample implementation:\n```javascript\n// src/test/mocks/handlers.js\nimport { rest } from 'msw'\n\nexport const handlers = [\n  // News API handlers\n  rest.get('/api/news', (req, res, ctx) => {\n    const category = req.url.searchParams.get('category') || 'general'\n    const searchTerm = req.url.searchParams.get('q') || ''\n    \n    // Mock different responses based on category/search\n    if (category === 'technology') {\n      return res(ctx.json({\n        articles: [\n          { id: '1', title: 'Tech News 1', description: 'Description 1', source: { name: 'Tech Source' }, publishedAt: '2023-01-01T12:00:00Z' },\n          { id: '2', title: 'Tech News 2', description: 'Description 2', source: { name: 'Tech Source' }, publishedAt: '2023-01-02T12:00:00Z' }\n        ]\n      }))\n    }\n    \n    if (searchTerm) {\n      return res(ctx.json({\n        articles: [\n          { id: '3', title: `News about ${searchTerm}`, description: `Description about ${searchTerm}`, source: { name: 'Search Source' }, publishedAt: '2023-01-03T12:00:00Z' }\n        ]\n      }))\n    }\n    \n    return res(ctx.json({\n      articles: [\n        { id: '4', title: 'General News 1', description: 'Description 3', source: { name: 'News Source' }, publishedAt: '2023-01-04T12:00:00Z' },\n        { id: '5', title: 'General News 2', description: 'Description 4', source: { name: 'News Source' }, publishedAt: '2023-01-05T12:00:00Z' }\n      ]\n    }))\n  }),\n  \n  // Article content handler\n  rest.get('/api/article/:id', (req, res, ctx) => {\n    const { id } = req.params\n    \n    if (id === 'error') {\n      return res(ctx.status(500), ctx.json({ error: 'Failed to fetch article' }))\n    }\n    \n    return res(ctx.json({\n      id,\n      title: `Article ${id}`,\n      content: `Full content for article ${id}. This is a longer text that would represent the full article content.`,\n      author: 'Test Author',\n      publishedAt: '2023-01-01T12:00:00Z',\n      source: { name: 'Test Source' }\n    }))\n  }),\n  \n  // Location API handler\n  rest.get('/api/location', (req, res, ctx) => {\n    return res(ctx.json({\n      city: 'New York',\n      country: 'US',\n      coordinates: { lat: 40.7128, lng: -74.0060 }\n    }))\n  }),\n  \n  // Cartoon generation API handlers\n  rest.post('/api/cartoon/concept', (req, res, ctx) => {\n    const { title, content } = req.body\n    \n    if (!title || !content) {\n      return res(ctx.status(400), ctx.json({ error: 'Missing required fields' }))\n    }\n    \n    return res(ctx.json({\n      concept: `A funny cartoon about ${title.substring(0, 20)}...`\n    }))\n  }),\n  \n  rest.post('/api/cartoon/image', (req, res, ctx) => {\n    const { concept } = req.body\n    \n    if (!concept) {\n      return res(ctx.status(400), ctx.json({ error: 'Missing concept' }))\n    }\n    \n    return res(ctx.json({\n      imageUrl: 'https://example.com/mock-cartoon-image.png'\n    }))\n  })\n]\n\n// src/test/mocks/server.js\nimport { setupServer } from 'msw/node'\nimport { handlers } from './handlers'\n\nexport const server = setupServer(...handlers)\n\n// src/test/setup.js\nimport { server } from './mocks/server'\nimport '@testing-library/jest-dom'\n\n// Establish API mocking before all tests\nbeforeAll(() => server.listen())\n\n// Reset any request handlers that we may add during the tests\nafterEach(() => server.resetHandlers())\n\n// Clean up after the tests are finished\nafterAll(() => server.close())\n```",
            "status": "pending",
            "testStrategy": "Create handlers for all API endpoints used by components. Implement test scenarios for success, error, and loading states. Use request parameters to return different mock responses based on the request. Test edge cases like network errors and invalid responses."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement End-to-End and API Tests",
        "description": "Create comprehensive end-to-end tests for critical user journeys and API tests for backend endpoints using Playwright. Validate cross-browser compatibility and mobile responsiveness.",
        "details": "1. Set up E2E test structure:\n```javascript\n// e2e/fixtures/setup.js\nimport { test as base } from '@playwright/test'\n\nexport const test = base.extend({\n  // Custom fixture to log in before tests\n  authenticatedPage: async ({ page }, use) => {\n    // Set up any required state (cookies, local storage, etc.)\n    await page.goto('/')\n    await page.evaluate(() => {\n      localStorage.setItem('preferences', JSON.stringify({ theme: 'light', location: 'New York' }))\n    })\n    await use(page)\n  }\n})\n```\n\n2. Create E2E tests for location detection and news fetching:\n```javascript\n// e2e/location-news.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Location and News Features', () => {\n  test('automatically detects location and loads relevant news', async ({ page }) => {\n    // Mock geolocation API\n    await page.route('**/api/location', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ city: 'San Francisco', country: 'US' })\n      })\n    })\n    \n    await page.goto('/')\n    \n    // Verify location is displayed\n    await expect(page.locator('[data-testid=\"location-display\"]')).toContainText('San Francisco, US')\n    \n    // Verify news articles are loaded\n    await expect(page.locator('[data-testid=\"news-list\"]')).toBeVisible()\n    await expect(page.locator('[data-testid=\"news-card\"]')).toHaveCount.greaterThan(0)\n  })\n\n  test('allows manual location entry', async ({ page }) => {\n    await page.goto('/')\n    \n    // Click location change button\n    await page.click('[data-testid=\"change-location-button\"]')\n    \n    // Enter new location\n    await page.fill('[data-testid=\"location-input\"]', 'Tokyo')\n    await page.click('[data-testid=\"search-button\"]')\n    \n    // Verify new location is displayed\n    await expect(page.locator('[data-testid=\"location-display\"]')).toContainText('Tokyo')\n    \n    // Verify news is updated\n    await expect(page.locator('[data-testid=\"news-list\"]')).toBeVisible()\n  })\n})\n```\n\n3. Create E2E tests for cartoon generation flow:\n```javascript\n// e2e/cartoon-generation.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Cartoon Generation', () => {\n  test('generates cartoon concept from news article', async ({ page }) => {\n    // Mock API responses\n    await page.route('**/api/news/search', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({\n          articles: [{\n            id: '1',\n            title: 'Test Article',\n            description: 'This is a test article for cartoon generation'\n          }]\n        })\n      })\n    })\n    \n    await page.route('**/api/article/content', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ content: 'Full article content for testing' })\n      })\n    })\n    \n    await page.route('**/api/gemini/concept', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ concept: 'A funny cartoon about testing' })\n      })\n    })\n    \n    await page.goto('/')\n    \n    // Select an article\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    \n    // Verify article detail view\n    await expect(page.locator('[data-testid=\"article-content\"]')).toBeVisible()\n    \n    // Generate cartoon concept\n    await page.click('[data-testid=\"generate-cartoon-button\"]')\n    \n    // Verify concept is displayed\n    await expect(page.locator('[data-testid=\"cartoon-concept\"]')).toContainText('A funny cartoon about testing')\n  })\n\n  test('generates image from concept', async ({ page }) => {\n    // Mock API responses including image generation\n    await page.route('**/api/gemini/image', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ imageUrl: 'https://example.com/test-image.jpg' })\n      })\n    })\n    \n    // Set up page with concept already generated\n    await page.goto('/')\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    await page.click('[data-testid=\"generate-cartoon-button\"]')\n    \n    // Generate image\n    await page.click('[data-testid=\"generate-image-button\"]')\n    \n    // Verify image is displayed\n    await expect(page.locator('[data-testid=\"cartoon-image\"]')).toBeVisible()\n    await expect(page.locator('[data-testid=\"cartoon-image\"] img')).toHaveAttribute('src', 'https://example.com/test-image.jpg')\n  })\n\n  test('handles rate limiting', async ({ page }) => {\n    // Mock rate limit exceeded response\n    await page.route('**/api/gemini/image', async route => {\n      await route.fulfill({\n        status: 429,\n        body: JSON.stringify({ error: 'Rate limit exceeded. Try again later.' })\n      })\n    })\n    \n    // Set up page with concept already generated\n    await page.goto('/')\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    await page.click('[data-testid=\"generate-cartoon-button\"]')\n    \n    // Try to generate image\n    await page.click('[data-testid=\"generate-image-button\"]')\n    \n    // Verify rate limit error is displayed\n    await expect(page.locator('[data-testid=\"error-message\"]')).toContainText('Rate limit exceeded')\n  })\n})\n```\n\n4. Create E2E tests for settings persistence:\n```javascript\n// e2e/settings-persistence.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Settings Persistence', () => {\n  test('saves and restores user preferences', async ({ page }) => {\n    await page.goto('/')\n    \n    // Open settings\n    await page.click('[data-testid=\"settings-button\"]')\n    \n    // Change theme\n    await page.click('[data-testid=\"theme-selector\"] [value=\"dark\"]')\n    \n    // Save settings\n    await page.click('[data-testid=\"save-settings\"]')\n    \n    // Verify theme is applied\n    await expect(page.locator('body')).toHaveClass(/dark-theme/)\n    \n    // Reload page\n    await page.reload()\n    \n    // Verify settings persisted\n    await expect(page.locator('body')).toHaveClass(/dark-theme/)\n  })\n})\n```\n\n5. Create API tests:\n```javascript\n// e2e/api.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('API Endpoints', () => {\n  test('news search endpoint returns correct data', async ({ request }) => {\n    const response = await request.get('/api/news/search?location=London')\n    \n    expect(response.status()).toBe(200)\n    const data = await response.json()\n    expect(data).toHaveProperty('articles')\n    expect(Array.isArray(data.articles)).toBe(true)\n  })\n\n  test('article content endpoint returns article data', async ({ request }) => {\n    const response = await request.get('/api/article/content?id=test-article-id')\n    \n    expect(response.status()).toBe(200)\n    const data = await response.json()\n    expect(data).toHaveProperty('content')\n  })\n\n  test('handles invalid requests properly', async ({ request }) => {\n    const response = await request.get('/api/news/search') // Missing required parameter\n    \n    expect(response.status()).toBe(400)\n    const data = await response.json()\n    expect(data).toHaveProperty('error')\n  })\n\n  test('respects CORS headers', async ({ request }) => {\n    const response = await request.get('/api/news/search?location=London', {\n      headers: {\n        'Origin': 'https://example.com'\n      }\n    })\n    \n    expect(response.headers()['access-control-allow-origin']).toBeTruthy()\n  })\n})\n```\n\n6. Test cross-browser compatibility:\n```javascript\n// playwright.config.js (updated)\nexport default {\n  // ... other config\n  projects: [\n    { name: 'chromium', use: { browserName: 'chromium' } },\n    { name: 'firefox', use: { browserName: 'firefox' } },\n    { name: 'webkit', use: { browserName: 'webkit' } },\n    { name: 'mobile chrome', use: { browserName: 'chromium', viewport: { width: 390, height: 844 }, deviceScaleFactor: 2 } },\n    { name: 'mobile safari', use: { browserName: 'webkit', viewport: { width: 390, height: 844 }, deviceScaleFactor: 2 } }\n  ],\n}\n```\n\n7. Create visual regression tests:\n```javascript\n// e2e/visual.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Visual Regression', () => {\n  test('news page looks correct', async ({ page }) => {\n    await page.goto('/')\n    \n    // Wait for content to load\n    await page.waitForSelector('[data-testid=\"news-card\"]')\n    \n    // Take screenshot and compare\n    await expect(page).toHaveScreenshot('news-page.png')\n  })\n\n  test('article detail page looks correct', async ({ page }) => {\n    // Mock API responses\n    await page.route('**/api/news/search', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({\n          articles: [{\n            id: '1',\n            title: 'Test Article',\n            description: 'This is a test article'\n          }]\n        })\n      })\n    })\n    \n    await page.route('**/api/article/content', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ content: 'Full article content for testing' })\n      })\n    })\n    \n    await page.goto('/')\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    \n    // Wait for content to load\n    await page.waitForSelector('[data-testid=\"article-content\"]')\n    \n    // Take screenshot and compare\n    await expect(page).toHaveScreenshot('article-detail.png')\n  })\n})\n```",
        "testStrategy": "1. Use Playwright to create end-to-end tests that simulate real user interactions across different browsers.\n2. Mock API responses to create consistent test scenarios and test edge cases.\n3. Test all critical user journeys identified in the PRD.\n4. Validate that the application works correctly across different browsers (Chrome, Firefox, Safari).\n5. Test mobile responsiveness by using different viewport sizes.\n6. Create API tests to verify backend endpoints function correctly.\n7. Test error handling and recovery flows.\n8. Implement visual regression testing to catch unexpected UI changes.\n9. Test performance aspects like loading times and responsiveness.\n10. Verify that user preferences are correctly persisted between sessions.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up E2E Test Framework and Configuration",
            "description": "Configure Playwright for end-to-end testing, including browser configurations, test fixtures, and environment setup for different platforms.",
            "dependencies": [],
            "details": "1. Install Playwright and configure project settings:\n```javascript\n// playwright.config.js\nexport default {\n  testDir: './e2e',\n  timeout: 30000,\n  retries: 2,\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure'\n  },\n  projects: [\n    { name: 'chromium', use: { browserName: 'chromium' } },\n    { name: 'firefox', use: { browserName: 'firefox' } },\n    { name: 'webkit', use: { browserName: 'webkit' } },\n    { name: 'mobile chrome', use: { browserName: 'chromium', viewport: { width: 390, height: 844 }, deviceScaleFactor: 2 } },\n    { name: 'mobile safari', use: { browserName: 'webkit', viewport: { width: 390, height: 844 }, deviceScaleFactor: 2 } }\n  ],\n  reporter: [['html'], ['json', { outputFile: 'test-results/e2e-results.json' }]]\n}\n```\n\n2. Create test fixtures and utilities for common operations:\n```javascript\n// e2e/fixtures/setup.js\nimport { test as base } from '@playwright/test'\n\nexport const test = base.extend({\n  // Custom fixture to log in before tests\n  authenticatedPage: async ({ page }, use) => {\n    // Set up any required state (cookies, local storage, etc.)\n    await page.goto('/')\n    await page.evaluate(() => {\n      localStorage.setItem('preferences', JSON.stringify({ theme: 'light', location: 'New York' }))\n    })\n    await use(page)\n  },\n  // Custom fixture for mobile testing\n  mobilePage: async ({ page }, use) => {\n    // Configure for mobile viewport if not already set in project config\n    await page.setViewportSize({ width: 390, height: 844 })\n    await use(page)\n  }\n})\n```\n\n3. Set up API mocking utilities:\n```javascript\n// e2e/utils/api-mocks.js\nexport async function mockLocationAPI(page, location) {\n  await page.route('**/api/location', async route => {\n    await route.fulfill({\n      status: 200,\n      body: JSON.stringify(location)\n    })\n  })\n}\n\nexport async function mockNewsAPI(page, articles) {\n  await page.route('**/api/news/search**', async route => {\n    await route.fulfill({\n      status: 200,\n      body: JSON.stringify({ articles })\n    })\n  })\n}\n```",
            "status": "pending",
            "testStrategy": "Verify configuration by running a simple smoke test that confirms Playwright can launch browsers and access the application. Test fixtures by creating a simple test that uses each fixture and confirms it works as expected."
          },
          {
            "id": 2,
            "title": "Implement Core User Journey E2E Tests",
            "description": "Create end-to-end tests for the main user flows including location detection, news browsing, and article viewing.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create tests for location detection and news browsing:\n```javascript\n// e2e/location-news.spec.js\nimport { test, expect } from './fixtures/setup'\nimport { mockLocationAPI, mockNewsAPI } from './utils/api-mocks'\n\ntest.describe('Location and News Features', () => {\n  test('automatically detects location and loads relevant news', async ({ page }) => {\n    // Mock geolocation API\n    await mockLocationAPI(page, { city: 'San Francisco', country: 'US' })\n    \n    await page.goto('/')\n    \n    // Verify location is displayed\n    await expect(page.locator('[data-testid=\"location-display\"]')).toContainText('San Francisco, US')\n    \n    // Verify news articles are loaded\n    await expect(page.locator('[data-testid=\"news-list\"]')).toBeVisible()\n    await expect(page.locator('[data-testid=\"news-card\"]')).toHaveCount.greaterThan(0)\n  })\n\n  test('allows manual location entry', async ({ page }) => {\n    await page.goto('/')\n    \n    // Click location change button\n    await page.click('[data-testid=\"change-location-button\"]')\n    \n    // Enter new location\n    await page.fill('[data-testid=\"location-input\"]', 'Tokyo')\n    await page.click('[data-testid=\"search-button\"]')\n    \n    // Verify new location is displayed\n    await expect(page.locator('[data-testid=\"location-display\"]')).toContainText('Tokyo')\n    \n    // Verify news is updated\n    await expect(page.locator('[data-testid=\"news-list\"]')).toBeVisible()\n  })\n  \n  test('displays article details when clicking on news card', async ({ page }) => {\n    // Mock news API\n    await mockNewsAPI(page, [{\n      id: 'test-article-1',\n      title: 'Test Headline',\n      description: 'Test description',\n      source: { name: 'Test Source' },\n      publishedAt: '2023-01-01T12:00:00Z'\n    }])\n    \n    await page.goto('/')\n    \n    // Click on news card\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    \n    // Verify article detail view\n    await expect(page.locator('[data-testid=\"article-title\"]')).toContainText('Test Headline')\n    await expect(page.locator('[data-testid=\"article-content\"]')).toBeVisible()\n  })\n})\n```\n\n2. Create tests for settings and preferences:\n```javascript\n// e2e/settings-persistence.spec.js\nimport { test, expect } from './fixtures/setup'\n\ntest.describe('Settings Persistence', () => {\n  test('saves and restores user preferences', async ({ page }) => {\n    await page.goto('/')\n    \n    // Open settings\n    await page.click('[data-testid=\"settings-button\"]')\n    \n    // Change theme\n    await page.click('[data-testid=\"theme-selector\"] [value=\"dark\"]')\n    \n    // Save settings\n    await page.click('[data-testid=\"save-settings\"]')\n    \n    // Verify theme is applied\n    await expect(page.locator('body')).toHaveClass(/dark-theme/)\n    \n    // Reload page\n    await page.reload()\n    \n    // Verify settings persisted\n    await expect(page.locator('body')).toHaveClass(/dark-theme/)\n  })\n  \n  test('allows changing news preferences', async ({ page }) => {\n    await page.goto('/')\n    \n    // Open settings\n    await page.click('[data-testid=\"settings-button\"]')\n    \n    // Change news category preference\n    await page.selectOption('[data-testid=\"category-selector\"]', 'technology')\n    \n    // Save settings\n    await page.click('[data-testid=\"save-settings\"]')\n    \n    // Verify news is updated with technology category\n    await expect(page.locator('[data-testid=\"active-category\"]')).toContainText('Technology')\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Run tests across all configured browsers to verify cross-browser compatibility. Test both desktop and mobile configurations to ensure responsive behavior works correctly. Verify that tests pass consistently and aren't affected by timing issues."
          },
          {
            "id": 3,
            "title": "Implement Cartoon Generation E2E Tests",
            "description": "Create end-to-end tests for the cartoon generation flow, including concept generation, image creation, and error handling.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create tests for the cartoon generation flow:\n```javascript\n// e2e/cartoon-generation.spec.js\nimport { test, expect } from './fixtures/setup'\n\ntest.describe('Cartoon Generation', () => {\n  test.beforeEach(async ({ page }) => {\n    // Mock API responses\n    await page.route('**/api/news/search', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({\n          articles: [{\n            id: '1',\n            title: 'Test Article',\n            description: 'This is a test article for cartoon generation'\n          }]\n        })\n      })\n    })\n    \n    await page.route('**/api/article/content', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ content: 'Full article content for testing' })\n      })\n    })\n  })\n  \n  test('generates cartoon concept from news article', async ({ page }) => {\n    await page.route('**/api/gemini/concept', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ concept: 'A funny cartoon about testing' })\n      })\n    })\n    \n    await page.goto('/')\n    \n    // Select an article\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    \n    // Verify article detail view\n    await expect(page.locator('[data-testid=\"article-content\"]')).toBeVisible()\n    \n    // Generate cartoon concept\n    await page.click('[data-testid=\"generate-cartoon-button\"]')\n    \n    // Verify concept is displayed\n    await expect(page.locator('[data-testid=\"cartoon-concept\"]')).toContainText('A funny cartoon about testing')\n  })\n\n  test('generates image from concept', async ({ page }) => {\n    // Mock concept generation API\n    await page.route('**/api/gemini/concept', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ concept: 'A funny cartoon about testing' })\n      })\n    })\n    \n    // Mock image generation API\n    await page.route('**/api/gemini/image', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ imageUrl: 'https://example.com/test-image.jpg' })\n      })\n    })\n    \n    await page.goto('/')\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    await page.click('[data-testid=\"generate-cartoon-button\"]')\n    \n    // Generate image\n    await page.click('[data-testid=\"generate-image-button\"]')\n    \n    // Verify image is displayed\n    await expect(page.locator('[data-testid=\"cartoon-image\"]')).toBeVisible()\n    await expect(page.locator('[data-testid=\"cartoon-image\"] img')).toHaveAttribute('src', 'https://example.com/test-image.jpg')\n  })\n\n  test('handles rate limiting and API errors', async ({ page }) => {\n    // Mock concept generation success\n    await page.route('**/api/gemini/concept', async route => {\n      await route.fulfill({\n        status: 200,\n        body: JSON.stringify({ concept: 'A funny cartoon about testing' })\n      })\n    })\n    \n    // Mock rate limit exceeded response\n    await page.route('**/api/gemini/image', async route => {\n      await route.fulfill({\n        status: 429,\n        body: JSON.stringify({ error: 'Rate limit exceeded. Try again later.' })\n      })\n    })\n    \n    await page.goto('/')\n    await page.click('[data-testid=\"news-card\"]:first-child')\n    await page.click('[data-testid=\"generate-cartoon-button\"]')\n    \n    // Try to generate image\n    await page.click('[data-testid=\"generate-image-button\"]')\n    \n    // Verify rate limit error is displayed\n    await expect(page.locator('[data-testid=\"error-message\"]')).toContainText('Rate limit exceeded')\n    \n    // Verify retry button is available\n    await expect(page.locator('[data-testid=\"retry-button\"]')).toBeVisible()\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Test both happy paths and error scenarios. Use API mocking to simulate different API responses including success, rate limiting, and other errors. Verify that the UI correctly displays loading states, success states, and error messages."
          },
          {
            "id": 4,
            "title": "Implement API Tests",
            "description": "Create comprehensive API tests for all backend endpoints, testing response formats, error handling, and edge cases.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create API tests for news and location endpoints:\n```javascript\n// e2e/api/news-location.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('News and Location API Endpoints', () => {\n  test('news search endpoint returns correct data structure', async ({ request }) => {\n    const response = await request.get('/api/news/search?location=London')\n    \n    expect(response.status()).toBe(200)\n    const data = await response.json()\n    expect(data).toHaveProperty('articles')\n    expect(Array.isArray(data.articles)).toBe(true)\n    \n    if (data.articles.length > 0) {\n      const article = data.articles[0]\n      expect(article).toHaveProperty('id')\n      expect(article).toHaveProperty('title')\n      expect(article).toHaveProperty('description')\n      expect(article).toHaveProperty('publishedAt')\n      expect(article).toHaveProperty('source')\n    }\n  })\n\n  test('news search handles invalid parameters', async ({ request }) => {\n    const response = await request.get('/api/news/search') // Missing required parameter\n    \n    expect(response.status()).toBe(400)\n    const data = await response.json()\n    expect(data).toHaveProperty('error')\n  })\n\n  test('article content endpoint returns article data', async ({ request }) => {\n    // First get a valid article ID\n    const searchResponse = await request.get('/api/news/search?location=London')\n    const searchData = await searchResponse.json()\n    \n    if (searchData.articles && searchData.articles.length > 0) {\n      const articleId = searchData.articles[0].id\n      const response = await request.get(`/api/article/content?id=${articleId}`)\n      \n      expect(response.status()).toBe(200)\n      const data = await response.json()\n      expect(data).toHaveProperty('content')\n      expect(typeof data.content).toBe('string')\n    } else {\n      test.skip()\n    }\n  })\n\n  test('location API returns valid data', async ({ request }) => {\n    const response = await request.get('/api/location?query=New York')\n    \n    expect(response.status()).toBe(200)\n    const data = await response.json()\n    expect(data).toHaveProperty('city')\n    expect(data).toHaveProperty('country')\n  })\n})\n```\n\n2. Create API tests for Gemini integration endpoints:\n```javascript\n// e2e/api/gemini.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Gemini API Endpoints', () => {\n  test('concept generation endpoint returns valid data', async ({ request }) => {\n    const response = await request.post('/api/gemini/concept', {\n      data: {\n        articleContent: 'This is a test article about climate change and its effects on global economies.'\n      }\n    })\n    \n    expect(response.status()).toBe(200)\n    const data = await response.json()\n    expect(data).toHaveProperty('concept')\n    expect(typeof data.concept).toBe('string')\n  })\n\n  test('image generation endpoint returns valid data', async ({ request }) => {\n    const response = await request.post('/api/gemini/image', {\n      data: {\n        concept: 'A cartoon showing a businessman looking worried while standing on a melting globe'\n      }\n    })\n    \n    expect(response.status()).toBe(200)\n    const data = await response.json()\n    expect(data).toHaveProperty('imageUrl')\n    expect(typeof data.imageUrl).toBe('string')\n    expect(data.imageUrl).toMatch(/^https?:\\/\\//)\n  })\n\n  test('handles invalid input for concept generation', async ({ request }) => {\n    const response = await request.post('/api/gemini/concept', {\n      data: {\n        // Missing required articleContent\n      }\n    })\n    \n    expect(response.status()).toBe(400)\n    const data = await response.json()\n    expect(data).toHaveProperty('error')\n  })\n\n  test('respects CORS headers', async ({ request }) => {\n    const response = await request.get('/api/gemini/concept', {\n      headers: {\n        'Origin': 'https://example.com'\n      }\n    })\n    \n    expect(response.headers()['access-control-allow-origin']).toBeTruthy()\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Test all API endpoints with valid inputs, invalid inputs, and edge cases. Verify response status codes, headers (including CORS), and response body structure. Chain API calls where necessary to test endpoints that depend on data from other endpoints."
          },
          {
            "id": 5,
            "title": "Implement Cross-Browser and Responsive Tests",
            "description": "Create tests that specifically validate the application's behavior across different browsers and screen sizes, focusing on responsive design and browser-specific issues.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "1. Create visual regression tests for different viewports:\n```javascript\n// e2e/visual/responsive.spec.js\nimport { test, expect } from '@playwright/test'\n\n// Define viewport sizes to test\nconst viewports = [\n  { width: 1920, height: 1080, name: 'desktop' },\n  { width: 768, height: 1024, name: 'tablet' },\n  { width: 390, height: 844, name: 'mobile' }\n]\n\nfor (const viewport of viewports) {\n  test.describe(`Visual tests at ${viewport.name} resolution`, () => {\n    test.use({ viewport })\n    \n    test('news page layout is correct', async ({ page }) => {\n      await page.goto('/')\n      \n      // Wait for content to load\n      await page.waitForSelector('[data-testid=\"news-card\"]')\n      \n      // Take screenshot and compare\n      await expect(page).toHaveScreenshot(`news-page-${viewport.name}.png`)\n    })\n\n    test('article detail page layout is correct', async ({ page }) => {\n      // Mock API responses\n      await page.route('**/api/news/search', async route => {\n        await route.fulfill({\n          status: 200,\n          body: JSON.stringify({\n            articles: [{\n              id: '1',\n              title: 'Test Article',\n              description: 'This is a test article'\n            }]\n          })\n        })\n      })\n      \n      await page.route('**/api/article/content', async route => {\n        await route.fulfill({\n          status: 200,\n          body: JSON.stringify({ content: 'Full article content for testing' })\n        })\n      })\n      \n      await page.goto('/')\n      await page.click('[data-testid=\"news-card\"]:first-child')\n      \n      // Wait for content to load\n      await page.waitForSelector('[data-testid=\"article-content\"]')\n      \n      // Take screenshot and compare\n      await expect(page).toHaveScreenshot(`article-detail-${viewport.name}.png`)\n    })\n\n    test('cartoon generation UI is responsive', async ({ page }) => {\n      // Set up mocks for cartoon generation flow\n      await page.route('**/api/news/search', async route => {\n        await route.fulfill({\n          status: 200,\n          body: JSON.stringify({\n            articles: [{\n              id: '1',\n              title: 'Test Article',\n              description: 'This is a test article'\n            }]\n          })\n        })\n      })\n      \n      await page.route('**/api/article/content', async route => {\n        await route.fulfill({\n          status: 200,\n          body: JSON.stringify({ content: 'Full article content for testing' })\n        })\n      })\n      \n      await page.route('**/api/gemini/concept', async route => {\n        await route.fulfill({\n          status: 200,\n          body: JSON.stringify({ concept: 'A funny cartoon about testing' })\n        })\n      })\n      \n      // Navigate to article and generate concept\n      await page.goto('/')\n      await page.click('[data-testid=\"news-card\"]:first-child')\n      await page.click('[data-testid=\"generate-cartoon-button\"]')\n      \n      // Wait for concept to appear\n      await page.waitForSelector('[data-testid=\"cartoon-concept\"]')\n      \n      // Take screenshot and compare\n      await expect(page).toHaveScreenshot(`cartoon-concept-${viewport.name}.png`)\n    })\n  })\n}\n```\n\n2. Create tests for browser-specific features and interactions:\n```javascript\n// e2e/browser-specific.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Browser-specific tests', () => {\n  test('drag and drop works correctly', async ({ page, browserName }) => {\n    test.skip(browserName === 'webkit' && process.platform === 'darwin', 'Drag and drop has known issues in WebKit on macOS')\n    \n    await page.goto('/cartoon-editor')\n    \n    // Test drag and drop functionality\n    const sourceElement = page.locator('[data-testid=\"draggable-item\"]')\n    const targetElement = page.locator('[data-testid=\"drop-zone\"]')\n    \n    await sourceElement.dragTo(targetElement)\n    \n    // Verify the drop was successful\n    await expect(targetElement.locator('[data-testid=\"dropped-item\"]')).toBeVisible()\n  })\n\n  test('touch interactions work on mobile', async ({ page, browserName }) => {\n    // Only run this test on mobile configurations\n    test.skip(page.viewportSize().width >= 768, 'This test is for mobile only')\n    \n    await page.goto('/')\n    \n    // Test swipe gesture on news cards\n    const newsCard = page.locator('[data-testid=\"news-card\"]:first-child')\n    const cardBounds = await newsCard.boundingBox()\n    \n    // Simulate swipe gesture\n    await page.touchscreen.tap(cardBounds.x + cardBounds.width / 2, cardBounds.y + cardBounds.height / 2)\n    await page.touchscreen.move(cardBounds.x + cardBounds.width / 2 - 100, cardBounds.y + cardBounds.height / 2)\n    await page.touchscreen.up()\n    \n    // Verify swipe action (e.g., card shows save/share buttons)\n    await expect(page.locator('[data-testid=\"card-actions\"]')).toBeVisible()\n  })\n\n  test('local storage works across page reloads', async ({ page, browserName }) => {\n    await page.goto('/')\n    \n    // Set a preference\n    await page.evaluate(() => {\n      localStorage.setItem('testPreference', 'testValue')\n    })\n    \n    // Reload the page\n    await page.reload()\n    \n    // Verify preference persisted\n    const storedValue = await page.evaluate(() => localStorage.getItem('testPreference'))\n    expect(storedValue).toBe('testValue')\n  })\n})\n```",
            "status": "pending",
            "testStrategy": "Run tests on all configured browsers to identify browser-specific issues. Test at multiple viewport sizes to verify responsive design works correctly. Use visual regression testing to catch layout issues. Skip tests that are known to fail on specific browser/platform combinations with clear documentation of why they're skipped."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Performance Tests and Documentation",
        "description": "Create performance tests to measure component render performance, bundle size, lazy loading effectiveness, and API response times. Document the testing strategy, patterns, and procedures.",
        "details": "1. Set up performance testing tools:\n```bash\nnpm install --save-dev lighthouse @playwright/test web-vitals size-limit\n```\n\n2. Configure bundle size limits:\n```json\n// package.json\n{\n  \"size-limit\": [\n    {\n      \"path\": \"dist/index.js\",\n      \"limit\": \"250 KB\"\n    },\n    {\n      \"path\": \"dist/index.css\",\n      \"limit\": \"50 KB\"\n    }\n  ]\n}\n```\n\n3. Create component render performance tests:\n```javascript\n// src/performance/__tests__/render-performance.test.js\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport { NewsCard, NewsList, CartoonGenerator } from '../../components'\n\ndescribe('Component Render Performance', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  \n  it('NewsCard renders within performance budget', () => {\n    const startTime = performance.now()\n    \n    render(<NewsCard article={{\n      id: '1',\n      title: 'Test Article',\n      description: 'Test description',\n      source: { name: 'Test Source' },\n      publishedAt: '2023-01-01T12:00:00Z'\n    }} />)\n    \n    const endTime = performance.now()\n    const renderTime = endTime - startTime\n    \n    expect(renderTime).toBeLessThan(50) // 50ms budget\n  })\n\n  it('NewsList renders large lists efficiently', () => {\n    const articles = Array.from({ length: 50 }, (_, i) => ({\n      id: `${i}`,\n      title: `Article ${i}`,\n      description: `Description ${i}`,\n      source: { name: 'Test Source' },\n      publishedAt: '2023-01-01T12:00:00Z'\n    }))\n    \n    const startTime = performance.now()\n    \n    render(<NewsList articles={articles} />)\n    \n    const endTime = performance.now()\n    const renderTime = endTime - startTime\n    \n    expect(renderTime).toBeLessThan(200) // 200ms budget for 50 items\n  })\n})\n```\n\n4. Create Lighthouse tests with Playwright:\n```javascript\n// e2e/lighthouse.spec.js\nimport { test, expect } from '@playwright/test'\nimport { playAudit } from 'playwright-lighthouse'\n\ntest('homepage passes Lighthouse audits', async ({ browser }) => {\n  const page = await browser.newPage()\n  await page.goto('/')\n  \n  const { lhr } = await playAudit({\n    page,\n    thresholds: {\n      performance: 90,\n      accessibility: 90,\n      'best-practices': 90,\n      seo: 90\n    },\n    port: 9222\n  })\n  \n  expect(lhr.categories.performance.score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories.accessibility.score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories['best-practices'].score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories.seo.score).toBeGreaterThanOrEqual(0.9)\n})\n```\n\n5. Create API response time tests:\n```javascript\n// e2e/api-performance.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('API Performance', () => {\n  test('news search API responds within time budget', async ({ request }) => {\n    const startTime = Date.now()\n    \n    const response = await request.get('/api/news/search?location=London')\n    \n    const endTime = Date.now()\n    const responseTime = endTime - startTime\n    \n    expect(response.status()).toBe(200)\n    expect(responseTime).toBeLessThan(300) // 300ms budget\n  })\n\n  test('article content API responds within time budget', async ({ request }) => {\n    const startTime = Date.now()\n    \n    const response = await request.get('/api/article/content?id=test-article-id')\n    \n    const endTime = Date.now()\n    const responseTime = endTime - startTime\n    \n    expect(response.status()).toBe(200)\n    expect(responseTime).toBeLessThan(200) // 200ms budget\n  })\n})\n```\n\n6. Test lazy loading effectiveness:\n```javascript\n// e2e/lazy-loading.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('lazy loaded components load only when needed', async ({ page }) => {\n  // Track network requests\n  const requests = []\n  page.on('request', request => requests.push(request))\n  \n  await page.goto('/')\n  \n  // Get initial chunk count\n  const initialChunks = requests.filter(r => r.url().includes('chunk')).length\n  \n  // Navigate to a page with lazy-loaded components\n  await page.click('[data-testid=\"settings-button\"]')\n  \n  // Check that new chunks were loaded\n  const finalChunks = requests.filter(r => r.url().includes('chunk')).length\n  \n  expect(finalChunks).toBeGreaterThan(initialChunks)\n})\n```\n\n7. Create memory usage tests:\n```javascript\n// e2e/memory-usage.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('application maintains reasonable memory usage', async ({ page }) => {\n  await page.goto('/')\n  \n  // Get initial memory usage\n  const initialMemory = await page.evaluate(() => performance.memory.usedJSHeapSize)\n  \n  // Perform memory-intensive operations\n  for (let i = 0; i < 10; i++) {\n    // Load articles, generate cartoons, etc.\n    await page.click('[data-testid=\"refresh-button\"]')\n    await page.waitForTimeout(500)\n  }\n  \n  // Get final memory usage\n  const finalMemory = await page.evaluate(() => performance.memory.usedJSHeapSize)\n  \n  // Check for memory leaks (should not increase by more than 50%)\n  expect(finalMemory).toBeLessThan(initialMemory * 1.5)\n})\n```\n\n8. Create test documentation:\n```markdown\n# News Cartoon Application Testing Strategy\n\n## Overview\nThis document outlines the testing strategy for the News Cartoon application, including the types of tests, coverage goals, and best practices.\n\n## Test Types\n\n### Unit Tests\n- **Purpose**: Test individual functions, services, and stores in isolation\n- **Tools**: Vitest, React Testing Library\n- **Coverage Goal**: 80%+ for all modules\n- **Running**: `npm run test`\n\n### Component Tests\n- **Purpose**: Test React components in isolation\n- **Tools**: React Testing Library, Testing Library User Event\n- **Coverage Goal**: All components tested for props, state, and interactions\n- **Running**: `npm run test:components`\n\n### Integration Tests\n- **Purpose**: Test interactions between components, stores, and services\n- **Tools**: Vitest, React Testing Library, MSW\n- **Coverage Goal**: All critical flows covered\n- **Running**: `npm run test:integration`\n\n### End-to-End Tests\n- **Purpose**: Test complete user journeys\n- **Tools**: Playwright\n- **Coverage Goal**: All critical user paths covered\n- **Running**: `npm run test:e2e`\n\n### Performance Tests\n- **Purpose**: Ensure application meets performance targets\n- **Tools**: Lighthouse, size-limit, custom performance tests\n- **Coverage Goal**: All performance metrics within budget\n- **Running**: `npm run test:performance`\n\n## Test Data\n\n### Fixtures\nTest fixtures are located in `src/test/fixtures` and include:\n- Mock articles\n- Mock user preferences\n- Mock API responses\n\n### Mocks\nAPI mocks are defined in `src/test/mocks` using Mock Service Worker (MSW).\n\n## Best Practices\n\n### Writing Tests\n1. Test behavior, not implementation\n2. Use data-testid attributes for test selectors\n3. Mock external dependencies\n4. Test both success and error paths\n5. Keep tests independent and isolated\n\n### Test Organization\n1. Co-locate tests with the code they test\n2. Use descriptive test names\n3. Group related tests with describe blocks\n4. Use beforeEach for common setup\n\n## CI/CD Integration\nTests run automatically on:\n- Pull requests\n- Merges to main branch\n- Nightly builds\n\n## Troubleshooting\n\n### Common Issues\n1. **Flaky tests**: Check for race conditions, add proper waiting\n2. **Slow tests**: Look for unnecessary waits, optimize test setup\n3. **Failed API mocks**: Verify MSW handlers match actual API calls\n\n### Debugging\n1. Use `--debug` flag: `npm run test:e2e -- --debug`\n2. Check test videos and screenshots in `test-results/`\n3. Use console.log in tests (removed in production)\n```\n\n9. Create test running guidelines:\n```markdown\n# Running Tests\n\n## Quick Start\n```bash\n# Run all tests\nnpm run test:all\n\n# Run unit tests\nnpm run test\n\n# Run component tests\nnpm run test:components\n\n# Run E2E tests\nnpm run test:e2e\n\n# Run performance tests\nnpm run test:performance\n```\n\n## Watch Mode\n```bash\n# Run tests in watch mode\nnpm run test:watch\n```\n\n## Coverage Reports\n```bash\n# Generate coverage report\nnpm run test:coverage\n```\nCoverage reports are available in `coverage/index.html`\n\n## Debugging Tests\n\n### Unit and Component Tests\n```bash\n# Run specific test file\nnpm run test src/components/__tests__/NewsCard.test.jsx\n\n# Run tests with specific name\nnpm run test -- -t \"renders article information correctly\"\n```\n\n### E2E Tests\n```bash\n# Run with UI mode\nnpm run test:e2e -- --ui\n\n# Run specific test file\nnpm run test:e2e e2e/location-news.spec.js\n\n# Run on specific browser\nnpm run test:e2e -- --project=firefox\n```\n```",
        "testStrategy": "1. Use Lighthouse and custom performance tests to measure application performance metrics.\n2. Set up bundle size limits with size-limit to prevent performance regressions.\n3. Create tests to measure component render performance and identify bottlenecks.\n4. Test API response times to ensure they meet performance targets.\n5. Validate that lazy loading is working correctly to optimize initial load time.\n6. Monitor memory usage patterns to detect memory leaks.\n7. Document the testing strategy, patterns, and procedures for future reference.\n8. Create guidelines for running and debugging tests.\n9. Set up performance benchmarks to track changes over time.\n10. Ensure all performance tests are included in the CI/CD pipeline.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Performance Testing Tools and Bundle Size Limits",
            "description": "Install and configure performance testing tools including Lighthouse, Playwright, web-vitals, and size-limit. Set up bundle size limits in package.json to prevent performance regressions.",
            "dependencies": [],
            "details": "1. Install required performance testing dependencies:\n```bash\nnpm install --save-dev lighthouse @playwright/test web-vitals size-limit\n```\n\n2. Add size-limit configuration to package.json:\n```json\n\"size-limit\": [\n  {\n    \"path\": \"dist/index.js\",\n    \"limit\": \"250 KB\"\n  },\n  {\n    \"path\": \"dist/index.css\",\n    \"limit\": \"50 KB\"\n  }\n]\n```\n\n3. Add performance testing scripts to package.json:\n```json\n\"scripts\": {\n  \"test:performance\": \"npm run test:bundle-size && npm run test:lighthouse\",\n  \"test:bundle-size\": \"size-limit\",\n  \"test:lighthouse\": \"playwright test e2e/lighthouse.spec.js\"\n}\n```\n\n4. Create a basic Lighthouse test configuration file at e2e/lighthouse.spec.js",
            "status": "pending",
            "testStrategy": "Run the bundle size check to verify size-limit is properly configured. Check that all performance testing scripts execute without errors."
          },
          {
            "id": 2,
            "title": "Implement Component Render Performance Tests",
            "description": "Create tests to measure and validate the render performance of key React components, ensuring they render within specified time budgets.",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Create a performance test directory structure:\n```bash\nmkdir -p src/performance/__tests__\n```\n\n2. Implement render performance tests for key components:\n```javascript\n// src/performance/__tests__/render-performance.test.js\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport { NewsCard, NewsList, CartoonGenerator } from '../../components'\n\ndescribe('Component Render Performance', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  \n  it('NewsCard renders within performance budget', () => {\n    const startTime = performance.now()\n    \n    render(<NewsCard article={{\n      id: '1',\n      title: 'Test Article',\n      description: 'Test description',\n      source: { name: 'Test Source' },\n      publishedAt: '2023-01-01T12:00:00Z'\n    }} />)\n    \n    const endTime = performance.now()\n    const renderTime = endTime - startTime\n    \n    expect(renderTime).toBeLessThan(50) // 50ms budget\n  })\n\n  it('NewsList renders large lists efficiently', () => {\n    const articles = Array.from({ length: 50 }, (_, i) => ({\n      id: `${i}`,\n      title: `Article ${i}`,\n      description: `Description ${i}`,\n      source: { name: 'Test Source' },\n      publishedAt: '2023-01-01T12:00:00Z'\n    }))\n    \n    const startTime = performance.now()\n    \n    render(<NewsList articles={articles} />)\n    \n    const endTime = performance.now()\n    const renderTime = endTime - startTime\n    \n    expect(renderTime).toBeLessThan(200) // 200ms budget for 50 items\n  })\n\n  it('CartoonGenerator renders within performance budget', () => {\n    const startTime = performance.now()\n    \n    render(<CartoonGenerator article={{\n      id: '1',\n      title: 'Test Article',\n      description: 'Test description',\n      content: 'Test content that is longer for cartoon generation'\n    }} />)\n    \n    const endTime = performance.now()\n    const renderTime = endTime - startTime\n    \n    expect(renderTime).toBeLessThan(100) // 100ms budget\n  })\n})\n```\n\n3. Add a script to run component performance tests:\n```json\n\"scripts\": {\n  \"test:component-performance\": \"vitest run src/performance/__tests__/render-performance.test.js\"\n}\n```",
            "status": "pending",
            "testStrategy": "Run tests with different component sizes and props to identify performance bottlenecks. Adjust time budgets based on actual performance to set realistic but challenging targets."
          },
          {
            "id": 3,
            "title": "Create API Response Time and Lazy Loading Tests",
            "description": "Implement tests to measure API response times and verify that lazy-loaded components are only loaded when needed, reducing initial page load time.",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Create API response time tests:\n```javascript\n// e2e/api-performance.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest.describe('API Performance', () => {\n  test('news search API responds within time budget', async ({ request }) => {\n    const startTime = Date.now()\n    \n    const response = await request.get('/api/news/search?location=London')\n    \n    const endTime = Date.now()\n    const responseTime = endTime - startTime\n    \n    expect(response.status()).toBe(200)\n    expect(responseTime).toBeLessThan(300) // 300ms budget\n  })\n\n  test('article content API responds within time budget', async ({ request }) => {\n    const startTime = Date.now()\n    \n    const response = await request.get('/api/article/content?id=test-article-id')\n    \n    const endTime = Date.now()\n    const responseTime = endTime - startTime\n    \n    expect(response.status()).toBe(200)\n    expect(responseTime).toBeLessThan(200) // 200ms budget\n  })\n\n  test('cartoon generation API responds within time budget', async ({ request }) => {\n    const startTime = Date.now()\n    \n    const response = await request.post('/api/cartoon/generate', {\n      data: {\n        articleContent: 'Test content for cartoon generation'\n      }\n    })\n    \n    const endTime = Date.now()\n    const responseTime = endTime - startTime\n    \n    expect(response.status()).toBe(200)\n    expect(responseTime).toBeLessThan(1000) // 1000ms budget for AI generation\n  })\n})\n```\n\n2. Create lazy loading effectiveness tests:\n```javascript\n// e2e/lazy-loading.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('lazy loaded components load only when needed', async ({ page }) => {\n  // Track network requests\n  const requests = []\n  page.on('request', request => requests.push(request))\n  \n  await page.goto('/')\n  \n  // Get initial chunk count\n  const initialChunks = requests.filter(r => r.url().includes('chunk')).length\n  \n  // Navigate to a page with lazy-loaded components\n  await page.click('[data-testid=\"settings-button\"]')\n  \n  // Check that new chunks were loaded\n  const finalChunks = requests.filter(r => r.url().includes('chunk')).length\n  \n  expect(finalChunks).toBeGreaterThan(initialChunks)\n})\n\ntest('cartoon generator loads only when article is expanded', async ({ page }) => {\n  const requests = []\n  page.on('request', request => requests.push(request))\n  \n  await page.goto('/')\n  \n  // Check initial requests don't include cartoon generator chunk\n  const initialCartoonChunks = requests.filter(r => \n    r.url().includes('chunk') && r.url().includes('cartoon')\n  ).length\n  \n  expect(initialCartoonChunks).toBe(0)\n  \n  // Expand an article to trigger lazy loading\n  await page.click('[data-testid=\"article-item\"]')\n  \n  // Wait for lazy loading\n  await page.waitForTimeout(500)\n  \n  // Check that cartoon generator chunk was loaded\n  const finalCartoonChunks = requests.filter(r => \n    r.url().includes('chunk') && r.url().includes('cartoon')\n  ).length\n  \n  expect(finalCartoonChunks).toBeGreaterThan(0)\n})\n```\n\n3. Add scripts to run these tests:\n```json\n\"scripts\": {\n  \"test:api-performance\": \"playwright test e2e/api-performance.spec.js\",\n  \"test:lazy-loading\": \"playwright test e2e/lazy-loading.spec.js\"\n}\n```",
            "status": "pending",
            "testStrategy": "Run API performance tests against both development and production environments to compare performance. For lazy loading tests, use network throttling to simulate different connection speeds and verify that lazy loading improves initial load time."
          },
          {
            "id": 4,
            "title": "Implement Lighthouse and Memory Usage Tests",
            "description": "Create automated Lighthouse tests to measure overall application performance, accessibility, SEO, and best practices. Implement memory usage tests to detect memory leaks.",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Create Lighthouse tests with Playwright:\n```javascript\n// e2e/lighthouse.spec.js\nimport { test, expect } from '@playwright/test'\nimport { playAudit } from 'playwright-lighthouse'\n\ntest('homepage passes Lighthouse audits', async ({ browser }) => {\n  const page = await browser.newPage()\n  await page.goto('/')\n  \n  const { lhr } = await playAudit({\n    page,\n    thresholds: {\n      performance: 90,\n      accessibility: 90,\n      'best-practices': 90,\n      seo: 90\n    },\n    port: 9222\n  })\n  \n  expect(lhr.categories.performance.score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories.accessibility.score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories['best-practices'].score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories.seo.score).toBeGreaterThanOrEqual(0.9)\n})\n\ntest('article detail page passes Lighthouse audits', async ({ browser }) => {\n  const page = await browser.newPage()\n  await page.goto('/article/test-article-id')\n  \n  const { lhr } = await playAudit({\n    page,\n    thresholds: {\n      performance: 85,\n      accessibility: 90,\n      'best-practices': 90,\n      seo: 90\n    },\n    port: 9222\n  })\n  \n  expect(lhr.categories.performance.score).toBeGreaterThanOrEqual(0.85)\n  expect(lhr.categories.accessibility.score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories['best-practices'].score).toBeGreaterThanOrEqual(0.9)\n  expect(lhr.categories.seo.score).toBeGreaterThanOrEqual(0.9)\n})\n```\n\n2. Create memory usage tests:\n```javascript\n// e2e/memory-usage.spec.js\nimport { test, expect } from '@playwright/test'\n\ntest('application maintains reasonable memory usage', async ({ page }) => {\n  await page.goto('/')\n  \n  // Get initial memory usage\n  const initialMemory = await page.evaluate(() => performance.memory.usedJSHeapSize)\n  \n  // Perform memory-intensive operations\n  for (let i = 0; i < 10; i++) {\n    // Load articles, generate cartoons, etc.\n    await page.click('[data-testid=\"refresh-button\"]')\n    await page.waitForTimeout(500)\n  }\n  \n  // Get final memory usage\n  const finalMemory = await page.evaluate(() => performance.memory.usedJSHeapSize)\n  \n  // Check for memory leaks (should not increase by more than 50%)\n  expect(finalMemory).toBeLessThan(initialMemory * 1.5)\n})\n\ntest('memory usage remains stable after multiple page navigations', async ({ page }) => {\n  await page.goto('/')\n  \n  const initialMemory = await page.evaluate(() => performance.memory.usedJSHeapSize)\n  \n  // Navigate between pages multiple times\n  for (let i = 0; i < 5; i++) {\n    await page.click('[data-testid=\"settings-button\"]')\n    await page.waitForTimeout(300)\n    await page.click('[data-testid=\"home-button\"]')\n    await page.waitForTimeout(300)\n  }\n  \n  const finalMemory = await page.evaluate(() => performance.memory.usedJSHeapSize)\n  \n  // Memory should not grow significantly\n  expect(finalMemory).toBeLessThan(initialMemory * 1.3)\n})\n```\n\n3. Add scripts to run these tests:\n```json\n\"scripts\": {\n  \"test:lighthouse\": \"playwright test e2e/lighthouse.spec.js\",\n  \"test:memory\": \"playwright test e2e/memory-usage.spec.js\"\n}\n```",
            "status": "pending",
            "testStrategy": "Run Lighthouse tests in headless mode for consistent results. For memory tests, run with different browsers to compare memory management. Consider running memory tests with a longer duration to detect slow memory leaks."
          },
          {
            "id": 5,
            "title": "Create Comprehensive Testing Documentation",
            "description": "Document the testing strategy, patterns, procedures, and guidelines for the entire application. Include information on running tests, troubleshooting, and best practices.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "1. Create a main testing documentation file:\n```markdown\n# News Cartoon Application Testing Strategy\n\n## Overview\nThis document outlines the testing strategy for the News Cartoon application, including the types of tests, coverage goals, and best practices.\n\n## Test Types\n\n### Unit Tests\n- **Purpose**: Test individual functions, services, and stores in isolation\n- **Tools**: Vitest, React Testing Library\n- **Coverage Goal**: 80%+ for all modules\n- **Running**: `npm run test`\n\n### Component Tests\n- **Purpose**: Test React components in isolation\n- **Tools**: React Testing Library, Testing Library User Event\n- **Coverage Goal**: All components tested for props, state, and interactions\n- **Running**: `npm run test:components`\n\n### Integration Tests\n- **Purpose**: Test interactions between components, stores, and services\n- **Tools**: Vitest, React Testing Library, MSW\n- **Coverage Goal**: All critical flows covered\n- **Running**: `npm run test:integration`\n\n### End-to-End Tests\n- **Purpose**: Test complete user journeys\n- **Tools**: Playwright\n- **Coverage Goal**: All critical user paths covered\n- **Running**: `npm run test:e2e`\n\n### Performance Tests\n- **Purpose**: Ensure application meets performance targets\n- **Tools**: Lighthouse, size-limit, custom performance tests\n- **Coverage Goal**: All performance metrics within budget\n- **Running**: `npm run test:performance`\n\n## Performance Testing Strategy\n\n### Component Render Performance\n- Each component has a render time budget\n- NewsCard: 50ms\n- NewsList (50 items): 200ms\n- CartoonGenerator: 100ms\n\n### API Response Times\n- News search API: 300ms\n- Article content API: 200ms\n- Cartoon generation API: 1000ms\n\n### Bundle Size Limits\n- Main JS bundle: 250KB\n- CSS: 50KB\n\n### Lighthouse Score Targets\n- Performance: 90+\n- Accessibility: 90+\n- Best Practices: 90+\n- SEO: 90+\n\n### Memory Usage\n- No more than 50% increase after intensive operations\n- No more than 30% increase after multiple page navigations\n\n## Test Data\n\n### Fixtures\nTest fixtures are located in `src/test/fixtures` and include:\n- Mock articles\n- Mock user preferences\n- Mock API responses\n\n### Mocks\nAPI mocks are defined in `src/test/mocks` using Mock Service Worker (MSW).\n\n## Best Practices\n\n### Writing Tests\n1. Test behavior, not implementation\n2. Use data-testid attributes for test selectors\n3. Mock external dependencies\n4. Test both success and error paths\n5. Keep tests independent and isolated\n\n### Test Organization\n1. Co-locate tests with the code they test\n2. Use descriptive test names\n3. Group related tests with describe blocks\n4. Use beforeEach for common setup\n\n## CI/CD Integration\nTests run automatically on:\n- Pull requests\n- Merges to main branch\n- Nightly builds\n\n## Troubleshooting\n\n### Common Issues\n1. **Flaky tests**: Check for race conditions, add proper waiting\n2. **Slow tests**: Look for unnecessary waits, optimize test setup\n3. **Failed API mocks**: Verify MSW handlers match actual API calls\n\n### Debugging\n1. Use `--debug` flag: `npm run test:e2e -- --debug`\n2. Check test videos and screenshots in `test-results/`\n3. Use console.log in tests (removed in production)\n```\n\n2. Create a test running guide:\n```markdown\n# Running Tests\n\n## Quick Start\n```bash\n# Run all tests\nnpm run test:all\n\n# Run unit tests\nnpm run test\n\n# Run component tests\nnpm run test:components\n\n# Run E2E tests\nnpm run test:e2e\n\n# Run performance tests\nnpm run test:performance\n```\n\n## Performance Tests\n```bash\n# Run all performance tests\nnpm run test:performance\n\n# Run bundle size checks\nnpm run test:bundle-size\n\n# Run component render performance tests\nnpm run test:component-performance\n\n# Run API performance tests\nnpm run test:api-performance\n\n# Run lazy loading tests\nnpm run test:lazy-loading\n\n# Run Lighthouse tests\nnpm run test:lighthouse\n\n# Run memory usage tests\nnpm run test:memory\n```\n\n## Watch Mode\n```bash\n# Run tests in watch mode\nnpm run test:watch\n```\n\n## Coverage Reports\n```bash\n# Generate coverage report\nnpm run test:coverage\n```\nCoverage reports are available in `coverage/index.html`\n\n## Debugging Tests\n\n### Unit and Component Tests\n```bash\n# Run specific test file\nnpm run test src/components/__tests__/NewsCard.test.jsx\n\n# Run tests with specific name\nnpm run test -- -t \"renders article information correctly\"\n```\n\n### E2E Tests\n```bash\n# Run with UI mode\nnpm run test:e2e -- --ui\n\n# Run specific test file\nnpm run test:e2e e2e/location-news.spec.js\n\n# Run on specific browser\nnpm run test:e2e -- --project=firefox\n```\n\n### Performance Tests\n```bash\n# Run with verbose logging\nnpm run test:performance -- --debug\n\n# Run with different performance thresholds\nLIGHTHOUSE_PERFORMANCE_THRESHOLD=85 npm run test:lighthouse\n```\n```\n\n3. Create a performance testing specific guide:\n```markdown\n# Performance Testing Guide\n\n## Overview\nThis guide explains how to run, interpret, and maintain the performance tests for the News Cartoon application.\n\n## Running Performance Tests\n\n### Prerequisites\n- Node.js 16+\n- Chrome browser installed (for Lighthouse tests)\n\n### Commands\n```bash\n# Run all performance tests\nnpm run test:performance\n\n# Run individual performance test suites\nnpm run test:bundle-size\nnpm run test:component-performance\nnpm run test:api-performance\nnpm run test:lazy-loading\nnpm run test:lighthouse\nnpm run test:memory\n```\n\n## Interpreting Results\n\n### Bundle Size\nThe size-limit tool will fail the build if bundles exceed the configured limits:\n- Main JS bundle: 250KB\n- CSS: 50KB\n\n### Component Render Performance\nTests will fail if components render slower than:\n- NewsCard: 50ms\n- NewsList (50 items): 200ms\n- CartoonGenerator: 100ms\n\n### API Response Times\nTests will fail if API responses take longer than:\n- News search API: 300ms\n- Article content API: 200ms\n- Cartoon generation API: 1000ms\n\n### Lighthouse Scores\nTests will fail if scores are below:\n- Performance: 90\n- Accessibility: 90\n- Best Practices: 90\n- SEO: 90\n\n### Memory Usage\nTests will fail if memory usage increases by:\n- More than 50% after intensive operations\n- More than 30% after multiple page navigations\n\n## Maintaining Performance Tests\n\n### Adjusting Thresholds\nIf performance tests are consistently failing or passing too easily, adjust thresholds in:\n- `package.json` for bundle size limits\n- Test files for component render times, API response times, etc.\n\n### Adding New Tests\n1. Create test files in appropriate directories\n2. Add new test scripts to package.json\n3. Update documentation\n\n### CI/CD Integration\nPerformance tests run on:\n- Pull requests (bundle size only)\n- Nightly builds (all performance tests)\n\n## Troubleshooting\n\n### Common Issues\n\n#### Inconsistent Lighthouse Scores\n- Run tests in headless mode\n- Ensure consistent network conditions\n- Run multiple times and average results\n\n#### Slow Component Render Times\n- Check for unnecessary re-renders\n- Look for expensive calculations in render path\n- Consider memoization or code splitting\n\n#### Memory Leaks\n- Check for event listeners not being cleaned up\n- Look for large objects being stored in state\n- Verify that components are properly unmounted\n```",
            "status": "pending",
            "testStrategy": "Review documentation with the team to ensure it's comprehensive and accurate. Update documentation as testing strategy evolves. Create a process for regularly reviewing and updating performance thresholds based on real-world usage data."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-09T02:17:20.187Z",
      "updated": "2025-11-09T02:37:01.537Z",
      "description": "Tasks for master context"
    }
  },
  "ui-simplification": {
    "tasks": [
      {
        "id": 1,
        "title": "Phase 1: Quick Wins",
        "description": "Implement quick UI improvements that can be done in 1-2 days with immediate impact",
        "details": "Focus on removing visual clutter, simplifying the color scheme, improving mobile touch targets, and implementing smart defaults. These changes should provide immediate improvement with minimal effort.",
        "testStrategy": "Visual regression testing, mobile responsiveness testing, user acceptance testing",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Simplify Color Scheme and Remove Gradients",
            "description": "Remove all gradient backgrounds and simplify the color scheme to a blue/gray palette throughout the application to reduce visual clutter and create a cleaner interface.",
            "dependencies": [],
            "details": "1. Update CSS variables to define a simplified blue/gray color palette\n2. Replace all gradient backgrounds with solid colors\n3. Ensure consistent color application across all UI components\n4. Update button styles to use the new color scheme\n5. Verify contrast ratios meet accessibility standards",
            "status": "pending",
            "testStrategy": "Visual regression testing to compare before/after screenshots; verify color contrast meets WCAG AA standards"
          },
          {
            "id": 2,
            "title": "Implement Smart Default Article Selection",
            "description": "Modify the article loading logic to automatically select the top 3 articles with the highest humor scores when news content loads.",
            "dependencies": [],
            "details": "1. Update the article loading function to sort articles by humor score\n2. Modify the selection logic to automatically check the top 3 highest-scoring articles\n3. Ensure the UI reflects these pre-selected articles\n4. Add visual indicators for pre-selected articles\n5. Maintain the ability for users to change selections manually",
            "status": "pending",
            "testStrategy": "Unit tests for sorting and selection logic; integration tests to verify correct articles are selected on page load"
          },
          {
            "id": 3,
            "title": "Set Default Panel Count and Simplify UI",
            "description": "Set the default panel count to 4 and remove the panel selector from the main UI to simplify the interface and streamline the user experience.",
            "dependencies": [],
            "details": "1. Update the default configuration to set panel count to 4\n2. Remove the panel selector component from the main UI\n3. Add the panel selection option to an advanced settings section if needed\n4. Update any related documentation or tooltips\n5. Ensure the comic generation works correctly with the fixed panel count",
            "status": "pending",
            "testStrategy": "Functional testing to verify comics generate with 4 panels by default; UI verification to confirm panel selector is removed"
          },
          {
            "id": 4,
            "title": "Increase Mobile Touch Targets",
            "description": "Increase all clickable elements to have a minimum height of 44px on mobile devices to improve usability and accessibility on touch screens.",
            "dependencies": [],
            "details": "1. Identify all interactive elements (buttons, links, form controls)\n2. Update CSS to ensure minimum 44px height and appropriate width for touch targets\n3. Add appropriate padding and margins to prevent accidental touches\n4. Test on various mobile device sizes\n5. Ensure changes don't negatively impact desktop layout",
            "status": "pending",
            "testStrategy": "Mobile device testing across different screen sizes; touch accuracy testing; verify no layout issues on desktop"
          },
          {
            "id": 5,
            "title": "Remove Redundant Information",
            "description": "Clean up the UI by removing duplicate summaries, unnecessary metadata, and other redundant information that adds visual clutter without providing value.",
            "dependencies": [],
            "details": "1. Identify all instances of duplicate content (summaries, timestamps, etc.)\n2. Remove redundant article metadata while preserving essential information\n3. Consolidate similar information into single, clear displays\n4. Simplify article preview cards to show only essential details\n5. Update layouts to accommodate the reduced content",
            "status": "pending",
            "testStrategy": "Visual inspection to verify removal of redundant elements; user testing to ensure no critical information was removed"
          }
        ]
      },
      {
        "id": 2,
        "title": "Phase 2: Core Improvements",
        "description": "Implement core UI improvements including wizard interface and workflow optimizations (3-5 days)",
        "details": "Transform the multi-step process into a cleaner wizard interface, add Quick Cartoon mode, implement progressive disclosure, combine related actions, and improve error handling.",
        "testStrategy": "End-to-end workflow testing, usability testing, error scenario testing",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Wizard Interface with Progress Tracking",
            "description": "Create a step-by-step wizard interface that clearly shows the user's progress through the cartoon generation workflow. Include step indicators, progress bar, and navigation controls.",
            "dependencies": [],
            "details": "Develop a wizard component with numbered steps and progress bar at the top. Each step should be a separate view with Next/Back buttons. Store the current step in state and implement navigation logic. Use CSS transitions for smooth step changes. Ensure the wizard is responsive and works on mobile devices.",
            "status": "pending",
            "testStrategy": "Test navigation between steps, verify progress tracking accuracy, ensure responsive design works across devices, and validate that state is preserved when moving between steps."
          },
          {
            "id": 2,
            "title": "Add Quick Cartoon Mode for Trending News",
            "description": "Implement a one-click cartoon generation feature that automatically selects trending news topics and generates cartoons without requiring manual input for each step.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create an API endpoint to fetch trending news topics. Implement a 'Quick Cartoon' button on the dashboard that triggers automatic selection of a trending topic, generates a script, creates characters, and produces the final cartoon. Add a loading indicator during generation and display the result with options to edit or share.",
            "status": "pending",
            "testStrategy": "Test the end-to-end quick generation process, verify trending topics are relevant, measure performance metrics for generation time, and test error handling when API calls fail."
          },
          {
            "id": 3,
            "title": "Implement Progressive Disclosure Pattern",
            "description": "Modify the UI to collapse completed sections and only show relevant information at each step, reducing cognitive load and simplifying the interface.",
            "dependencies": [
              "2.1"
            ],
            "details": "Add collapsible sections for each completed step in the wizard. When a step is completed, automatically collapse it and show a summary. Add an expand/collapse toggle for users to review previous steps if needed. Store the expanded/collapsed state in the application state. Ensure smooth animations for collapse/expand actions.",
            "status": "pending",
            "testStrategy": "Verify sections collapse correctly after completion, test that summaries accurately reflect the completed work, ensure expand/collapse functionality works properly, and check that the state is preserved during navigation."
          },
          {
            "id": 4,
            "title": "Combine Concept Selection with Script Generation",
            "description": "Merge the concept selection and script generation steps to reduce the overall number of steps in the workflow and create a more streamlined experience.",
            "dependencies": [
              "2.1",
              "2.3"
            ],
            "details": "Redesign the concept selection UI to include script generation in the same view. As users select a concept, dynamically show script options or a script editor. Implement real-time script generation based on the selected concept. Add preview functionality to show how the script will look with the selected concept. Update the wizard navigation to reflect the combined step.",
            "status": "pending",
            "testStrategy": "Test the combined workflow for usability, verify that script generation works correctly with different concept selections, ensure the preview functionality accurately reflects the final output, and test edge cases with unusual concept selections."
          },
          {
            "id": 5,
            "title": "Improve Error Handling with Inline Messages",
            "description": "Enhance error handling throughout the application with contextual inline error messages and automatic retry functionality for common errors.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "Implement a consistent error handling system that displays inline error messages near the relevant UI elements. Create error message components with appropriate styling for different severity levels. Add automatic retry logic for network-related errors with exponential backoff. Implement a global error boundary to catch unhandled exceptions. Add user-friendly error messages with suggested actions for recovery.",
            "status": "pending",
            "testStrategy": "Test various error scenarios including network failures, validation errors, and server errors. Verify that error messages are clear and actionable. Test automatic retry functionality with simulated network issues. Ensure errors are logged properly for debugging."
          }
        ]
      },
      {
        "id": 3,
        "title": "Phase 3: Advanced Features",
        "description": "Implement advanced features and optimizations (1 week)",
        "details": "Add inline editing capabilities, implement swipe gestures for mobile, optimize performance with lazy loading and caching, improve accessibility with ARIA labels and keyboard navigation, and create an advanced settings panel for power users.",
        "testStrategy": "Performance testing, accessibility testing (WCAG compliance), cross-browser testing, gesture testing on mobile devices",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Inline Editing for Scripts",
            "description": "Add the ability to edit script content directly within the viewing interface without requiring users to switch to a separate edit mode.",
            "dependencies": [],
            "details": "Create an editable content system using contentEditable or a rich text editor component. Implement auto-saving functionality that preserves changes after a brief period of inactivity. Add visual indicators to show which elements are editable on hover. Include formatting controls that appear contextually when text is selected. Ensure proper validation and error handling for edited content.",
            "status": "pending",
            "testStrategy": "Unit tests for edit functionality, integration tests for auto-save feature, usability testing with content creators to validate the editing experience."
          },
          {
            "id": 2,
            "title": "Add Swipe Gestures for Mobile Navigation",
            "description": "Implement touch-based swipe gestures to allow mobile users to navigate between steps in the script creation process.",
            "dependencies": [],
            "details": "Integrate a touch gesture library like Hammer.js to detect horizontal swipe actions. Add smooth transitions between steps when swiping left (next) or right (previous). Implement velocity-based animations that respond to the speed of the user's swipe. Include visual indicators during swipe to show the destination. Add haptic feedback for successful navigation events on supported devices.",
            "status": "pending",
            "testStrategy": "Mobile device testing across different screen sizes, gesture recognition accuracy testing, performance testing for animation smoothness."
          },
          {
            "id": 3,
            "title": "Optimize Performance with Lazy Loading and Caching",
            "description": "Improve application performance by implementing lazy loading for content and establishing an effective caching strategy.",
            "dependencies": [],
            "details": "Implement intersection observer API to load content only when it's about to enter the viewport. Set up a service worker to cache static assets and API responses. Add prefetching for likely next steps based on user navigation patterns. Implement image optimization with responsive loading based on device capabilities. Create a memory management system that unloads content that's no longer needed.",
            "status": "pending",
            "testStrategy": "Performance benchmarking before and after implementation, load time measurements, memory usage monitoring, testing on low-end devices to ensure improvements are universal."
          },
          {
            "id": 4,
            "title": "Improve Accessibility with ARIA and Keyboard Navigation",
            "description": "Enhance the application's accessibility by adding proper ARIA attributes and implementing comprehensive keyboard navigation.",
            "dependencies": [],
            "details": "Audit existing components and add appropriate ARIA roles, states, and properties. Implement focus management system that maintains a logical tab order. Create keyboard shortcuts for common actions with a visible shortcut reference. Ensure all interactive elements are keyboard accessible with visible focus states. Add screen reader announcements for dynamic content changes and important notifications.",
            "status": "pending",
            "testStrategy": "Accessibility testing with screen readers (NVDA, JAWS, VoiceOver), keyboard-only navigation testing, automated accessibility testing with tools like axe, and manual WCAG 2.1 AA compliance verification."
          },
          {
            "id": 5,
            "title": "Create Advanced Settings Panel for Power Users",
            "description": "Develop a comprehensive settings panel that allows power users to customize their experience and access advanced features.",
            "dependencies": [
              "3.1",
              "3.3",
              "3.4"
            ],
            "details": "Design a modal or sidebar settings panel with categorized options. Implement user preference persistence using localStorage or user profiles. Add advanced options including theme customization, keyboard shortcut configuration, default view preferences, and performance settings (caching levels, prefetch behavior). Include export/import functionality for settings to share configurations between devices or users.",
            "status": "pending",
            "testStrategy": "User testing with power users and administrators, settings persistence testing across sessions, validation of setting effects on application behavior."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-14T23:33:40.512Z",
      "updated": "2025-11-14T23:34:10.803Z",
      "description": "UI/UX simplification and improvements to reduce complexity and improve user experience"
    }
  },
  "ui-redesign": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Editorial Newspaper Typography System",
        "description": "Replace all system fonts with newspaper-inspired fonts: Playfair Display for headlines, Crimson Text for body text, and Courier Prime for UI labels. Configure font loading and create typography CSS variables.",
        "details": "1. Add the required font files to the project:\n   - Download Playfair Display, Crimson Text, and Courier Prime from Google Fonts or another reliable source\n   - Include all necessary font weights and styles (regular, bold, italic)\n   - Place font files in an `/assets/fonts/` directory\n\n2. Configure font loading in the project:\n   - Use `@font-face` declarations in a dedicated typography CSS file\n   - Implement font loading optimization techniques (WOFF2 format, preloading critical fonts)\n   - Example:\n     ```css\n     @font-face {\n       font-family: 'Playfair Display';\n       src: url('/assets/fonts/playfair-display-regular.woff2') format('woff2');\n       font-weight: 400;\n       font-style: normal;\n       font-display: swap;\n     }\n     /* Repeat for other weights/styles and fonts */\n     ```\n\n3. Create a comprehensive typography CSS variables system:\n   - Define root variables for font families:\n     ```css\n     :root {\n       --font-headlines: 'Playfair Display', serif;\n       --font-body: 'Crimson Text', serif;\n       --font-ui: 'Courier Prime', monospace;\n     }\n     ```\n   - Define variables for font sizes, line heights, and letter spacing:\n     ```css\n     :root {\n       /* Font sizes */\n       --font-size-h1: 2.5rem;\n       --font-size-h2: 2rem;\n       --font-size-h3: 1.75rem;\n       --font-size-body: 1.125rem;\n       --font-size-ui: 0.875rem;\n       \n       /* Line heights */\n       --line-height-headlines: 1.2;\n       --line-height-body: 1.5;\n       --line-height-ui: 1.4;\n       \n       /* Letter spacing */\n       --letter-spacing-headlines: -0.02em;\n       --letter-spacing-body: 0;\n       --letter-spacing-ui: 0.05em;\n     }\n     ```\n\n4. Apply the typography system throughout the application:\n   - Update all existing CSS to use the new variables\n   - Create utility classes for common typography patterns\n   - Example:\n     ```css\n     h1, h2, h3, h4, h5, h6 {\n       font-family: var(--font-headlines);\n       line-height: var(--line-height-headlines);\n       letter-spacing: var(--letter-spacing-headlines);\n     }\n     \n     body {\n       font-family: var(--font-body);\n       font-size: var(--font-size-body);\n       line-height: var(--line-height-body);\n     }\n     \n     button, input, select, .ui-element {\n       font-family: var(--font-ui);\n       font-size: var(--font-size-ui);\n       line-height: var(--line-height-ui);\n       letter-spacing: var(--letter-spacing-ui);\n     }\n     ```\n\n5. Ensure responsive typography:\n   - Implement a fluid typography system using clamp() or media queries\n   - Adjust font sizes proportionally across different viewport sizes\n\n6. Document the typography system:\n   - Create a typography style guide page\n   - Document all variables and their intended usage",
        "testStrategy": "1. Visual Inspection:\n   - Verify that all headlines use Playfair Display\n   - Verify that all body text uses Crimson Text\n   - Verify that all UI elements use Courier Prime\n   - Check rendering across different browsers (Chrome, Firefox, Safari, Edge)\n   - Verify font appearance on both desktop and mobile devices\n\n2. Code Review:\n   - Ensure all font files are properly included in the project\n   - Verify that @font-face declarations are correctly implemented\n   - Confirm that CSS variables are properly defined and follow naming conventions\n   - Check that all typography styles use the CSS variables instead of hardcoded values\n\n3. Performance Testing:\n   - Use Lighthouse or WebPageTest to measure font loading performance\n   - Verify that font files are properly optimized (WOFF2 format)\n   - Check for any font-related performance issues (FOUT, FOIT)\n   - Ensure critical fonts are preloaded appropriately\n\n4. Cross-browser Testing:\n   - Test the typography system in all major browsers\n   - Verify consistent rendering across different operating systems\n   - Check for any font rendering issues on Windows, macOS, iOS, and Android\n\n5. Accessibility Testing:\n   - Verify that text remains readable at different zoom levels\n   - Check color contrast with the new fonts\n   - Test with screen readers to ensure proper reading of text\n   - Verify that font sizes meet minimum accessibility requirements\n\n6. Responsive Testing:\n   - Test typography at various viewport sizes\n   - Verify that text remains readable on mobile devices\n   - Check that font scaling works correctly across breakpoints",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Download and organize font files",
            "description": "Download the required newspaper-inspired fonts (Playfair Display, Crimson Text, and Courier Prime) from Google Fonts or another reliable source, including all necessary weights and styles, and organize them in the project directory structure.",
            "dependencies": [],
            "details": "1. Create an `/assets/fonts/` directory in the project\n2. Download the following fonts with all necessary weights (regular, bold, italic):\n   - Playfair Display (serif) for headlines\n   - Crimson Text (serif) for body text\n   - Courier Prime (monospace) for UI labels\n3. Organize fonts into subdirectories by font family:\n   - `/assets/fonts/playfair-display/`\n   - `/assets/fonts/crimson-text/`\n   - `/assets/fonts/courier-prime/`\n4. Ensure all fonts are in WOFF2 format for optimal performance\n5. Verify all font files are properly named according to weight and style (e.g., `playfair-display-bold.woff2`)",
            "status": "pending",
            "testStrategy": "Verify all required font files are present in the correct directories with appropriate naming conventions and formats."
          },
          {
            "id": 2,
            "title": "Configure font loading with @font-face declarations",
            "description": "Create a dedicated typography CSS file with @font-face declarations for all font files, implementing optimization techniques like WOFF2 format and font-display swap.",
            "dependencies": [],
            "details": "1. Create a new file `/assets/styles/typography.css`\n2. Add @font-face declarations for each font weight and style:\n```css\n@font-face {\n  font-family: 'Playfair Display';\n  src: url('/assets/fonts/playfair-display/playfair-display-regular.woff2') format('woff2');\n  font-weight: 400;\n  font-style: normal;\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'Playfair Display';\n  src: url('/assets/fonts/playfair-display/playfair-display-bold.woff2') format('woff2');\n  font-weight: 700;\n  font-style: normal;\n  font-display: swap;\n}\n```\n3. Repeat for all weights and styles of each font family\n4. Add preload links in the HTML head for critical fonts:\n```html\n<link rel=\"preload\" href=\"/assets/fonts/playfair-display/playfair-display-bold.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n```\n5. Import the typography.css file in the main stylesheet or entry point",
            "status": "pending",
            "testStrategy": "Test font loading in different browsers to ensure fonts are properly loaded and displayed. Check network tab in developer tools to verify optimization techniques are working correctly."
          },
          {
            "id": 3,
            "title": "Create typography CSS variables system",
            "description": "Establish a comprehensive set of CSS variables for font families, sizes, line heights, and letter spacing to create a consistent typography system throughout the application.",
            "dependencies": [],
            "details": "1. Add the following CSS variables to the `:root` selector in typography.css:\n```css\n:root {\n  /* Font families */\n  --font-headlines: 'Playfair Display', serif;\n  --font-body: 'Crimson Text', serif;\n  --font-ui: 'Courier Prime', monospace;\n  \n  /* Font sizes */\n  --font-size-h1: 2.5rem;\n  --font-size-h2: 2rem;\n  --font-size-h3: 1.75rem;\n  --font-size-h4: 1.5rem;\n  --font-size-h5: 1.25rem;\n  --font-size-h6: 1.125rem;\n  --font-size-body: 1.125rem;\n  --font-size-body-small: 1rem;\n  --font-size-ui: 0.875rem;\n  \n  /* Line heights */\n  --line-height-headlines: 1.2;\n  --line-height-body: 1.5;\n  --line-height-ui: 1.4;\n  \n  /* Letter spacing */\n  --letter-spacing-headlines: -0.02em;\n  --letter-spacing-body: 0;\n  --letter-spacing-ui: 0.05em;\n}\n```\n2. Add responsive typography using clamp() for fluid scaling:\n```css\n:root {\n  --font-size-h1: clamp(2rem, 5vw, 2.5rem);\n  --font-size-h2: clamp(1.75rem, 4vw, 2rem);\n  /* Continue for other sizes */\n}\n```\n3. Create a set of utility classes for common typography patterns",
            "status": "pending",
            "testStrategy": "Verify that all CSS variables are properly defined and accessible throughout the application. Test the responsive typography at different viewport sizes to ensure proper scaling."
          },
          {
            "id": 4,
            "title": "Apply typography system to HTML elements",
            "description": "Update all existing CSS to use the new typography variables, creating base styles for HTML elements and utility classes for common typography patterns.",
            "dependencies": [],
            "details": "1. Create base styles for HTML elements in typography.css:\n```css\n/* Headline styles */\nh1, h2, h3, h4, h5, h6 {\n  font-family: var(--font-headlines);\n  line-height: var(--line-height-headlines);\n  letter-spacing: var(--letter-spacing-headlines);\n  margin-bottom: 0.5em;\n  font-weight: 700;\n}\n\nh1 { font-size: var(--font-size-h1); }\nh2 { font-size: var(--font-size-h2); }\nh3 { font-size: var(--font-size-h3); }\nh4 { font-size: var(--font-size-h4); }\nh5 { font-size: var(--font-size-h5); }\nh6 { font-size: var(--font-size-h6); }\n\n/* Body text styles */\nbody {\n  font-family: var(--font-body);\n  font-size: var(--font-size-body);\n  line-height: var(--line-height-body);\n  letter-spacing: var(--letter-spacing-body);\n}\n\np {\n  margin-bottom: 1em;\n}\n\n/* UI element styles */\nbutton, input, select, textarea, .ui-element {\n  font-family: var(--font-ui);\n  font-size: var(--font-size-ui);\n  line-height: var(--line-height-ui);\n  letter-spacing: var(--letter-spacing-ui);\n}\n```\n2. Create utility classes for common typography patterns:\n```css\n.headline-large { font-size: calc(var(--font-size-h1) * 1.5); }\n.headline-medium { font-size: var(--font-size-h1); }\n.headline-small { font-size: var(--font-size-h2); }\n.body-large { font-size: calc(var(--font-size-body) * 1.2); }\n.body-small { font-size: var(--font-size-body-small); }\n.text-ui { font-family: var(--font-ui); }\n```\n3. Update any component-specific CSS files to use the new variables",
            "status": "pending",
            "testStrategy": "Visually inspect all text elements in the application to ensure they are using the correct fonts, sizes, and spacing. Test across different browsers and devices to verify consistent rendering."
          },
          {
            "id": 5,
            "title": "Create typography documentation and style guide",
            "description": "Document the typography system by creating a comprehensive style guide page that showcases all typography elements, variables, and their intended usage.",
            "dependencies": [],
            "details": "1. Create a new page or component called `TypographyStyleGuide.jsx` (or appropriate format for your project)\n2. Include sections for:\n   - Font families (with visual examples)\n   - Headline hierarchy (h1-h6)\n   - Body text variations\n   - UI text elements\n   - Typography utility classes\n3. Display the actual CSS variable names alongside each example:\n```jsx\n<div className=\"style-guide-section\">\n  <h2>Headline Typography</h2>\n  <div className=\"style-guide-item\">\n    <h1>Headline Level 1</h1>\n    <code>font-family: var(--font-headlines); font-size: var(--font-size-h1);</code>\n  </div>\n  {/* Repeat for other elements */}\n</div>\n```\n4. Include a section on proper usage guidelines:\n   - When to use each headline level\n   - Recommended text length for optimal readability\n   - Accessibility considerations\n5. Add code snippets showing how to implement the typography in components\n6. Include the style guide in project documentation",
            "status": "pending",
            "testStrategy": "Review the style guide for completeness, ensuring all typography elements are documented. Verify that the displayed examples match the actual implementation in the application."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Editorial Newspaper Color Palette",
        "description": "Replace the current purple-pink gradient color scheme with an Editorial Newspaper palette using off-white newsprint background, rich black ink, editorial red accents, and press yellow highlights. Create CSS variables for consistent theming.",
        "details": "1. Create a dedicated CSS file for color variables:\n   - Create `/assets/styles/colors.css` or add to an existing theming file\n   - Define the following CSS variables:\n     ```css\n     :root {\n       --color-background: #F8F5F0; /* off-white newsprint */\n       --color-text: #1A1A1A; /* rich black ink */\n       --color-accent: #CC2936; /* editorial red */\n       --color-highlight: #FFE66D; /* press yellow */\n       \n       /* Add secondary/tertiary variations as needed */\n       --color-background-alt: #F0EBE3; /* slightly darker off-white */\n       --color-text-muted: #4D4D4D; /* lighter black for secondary text */\n       --color-accent-light: #E05A65; /* lighter red */\n       --color-highlight-light: #FFF0A3; /* lighter yellow */\n     }\n     ```\n\n2. Update all component styles to use the new color variables:\n   - Replace all instances of the purple-pink gradient with appropriate newspaper palette colors\n   - Update background colors to use `var(--color-background)` or variations\n   - Change text colors to use `var(--color-text)` or variations\n   - Apply accent colors to interactive elements, buttons, and links using `var(--color-accent)`\n   - Use highlight colors for notifications, badges, or emphasis using `var(--color-highlight)`\n\n3. Create color utility classes for common use cases:\n   ```css\n   .bg-newsprint { background-color: var(--color-background); }\n   .bg-newsprint-alt { background-color: var(--color-background-alt); }\n   .text-ink { color: var(--color-text); }\n   .text-ink-muted { color: var(--color-text-muted); }\n   .accent-red { color: var(--color-accent); }\n   .bg-accent-red { background-color: var(--color-accent); }\n   .highlight-yellow { color: var(--color-highlight); }\n   .bg-highlight-yellow { background-color: var(--color-highlight); }\n   ```\n\n4. Update any existing color-related components:\n   - Modify button styles to use the new color scheme\n   - Update form elements (inputs, checkboxes, radio buttons)\n   - Revise navigation elements and menus\n   - Adjust card/panel backgrounds and borders\n\n5. Ensure accessibility compliance:\n   - Verify color contrast ratios meet WCAG AA standards (minimum 4.5:1 for normal text, 3:1 for large text)\n   - Test with color blindness simulators to ensure information is not conveyed by color alone\n   - Add additional contrast where needed",
        "testStrategy": "1. Visual Inspection:\n   - Verify that all UI components use the new color palette\n   - Confirm that no instances of the old purple-pink gradient remain\n   - Check that colors are applied consistently across the application\n   - Verify that the application maintains a cohesive newspaper-inspired aesthetic\n\n2. Code Review:\n   - Ensure all hardcoded color values have been replaced with CSS variables\n   - Verify that the color variables are properly defined and organized\n   - Check that utility classes are implemented correctly\n   - Confirm that no inline styles bypass the theming system\n\n3. Accessibility Testing:\n   - Use tools like Lighthouse, WAVE, or axe to verify color contrast compliance\n   - Test with color blindness simulators (Deuteranopia, Protanopia, Tritanopia)\n   - Verify that interactive elements have appropriate focus states\n   - Ensure information is not conveyed by color alone\n\n4. Cross-browser Testing:\n   - Verify consistent color rendering across Chrome, Firefox, Safari, and Edge\n   - Check appearance on both desktop and mobile devices\n   - Test with different screen brightness and color settings\n\n5. Performance Testing:\n   - Verify that the CSS file size remains reasonable\n   - Check that the new color system doesn't introduce any rendering performance issues",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Newspaper-Inspired Layout Components",
        "description": "Develop a set of reusable layout components that mimic traditional newspaper design including multi-column layouts, masthead headers, section dividers with vintage borders, and torn paper edge effects.",
        "details": "1. Create Multi-Column Layout Component:\n   - Implement a responsive grid system for news articles using CSS Grid\n   - Create at least three column variations (2-column, 3-column, and 4-column layouts)\n   - Ensure proper text flow between columns with appropriate gutters\n   - Add media queries to collapse to fewer columns on smaller screens\n   - Example implementation:\n     ```css\n     .newspaper-columns-2 {\n       display: grid;\n       grid-template-columns: repeat(2, 1fr);\n       gap: 1.5rem;\n     }\n     \n     .newspaper-columns-3 {\n       display: grid;\n       grid-template-columns: repeat(3, 1fr);\n       gap: 1.25rem;\n     }\n     \n     /* Add responsive breakpoints */\n     @media (max-width: 768px) {\n       .newspaper-columns-3 {\n         grid-template-columns: repeat(2, 1fr);\n       }\n     }\n     ```\n\n2. Implement Newspaper Masthead Header:\n   - Create a component for the top newspaper header with publication name\n   - Include date, edition number, and optional weather information\n   - Style with appropriate typography from Task #1\n   - Add subtle texture or aging effects to enhance vintage appearance\n   - Example structure:\n     ```html\n     <header class=\"newspaper-masthead\">\n       <div class=\"masthead-date\">MONDAY, JUNE 5, 2023</div>\n       <h1 class=\"masthead-title\">THE DAILY CHRONICLE</h1>\n       <div class=\"masthead-edition\">MORNING EDITION  VOL. CXIV, NO. 35</div>\n     </header>\n     ```\n\n3. Develop Section Dividers with Vintage Borders:\n   - Create horizontal dividers with classic newspaper styling\n   - Implement at least three border variations (single line, double line, decorative)\n   - Use SVG patterns for more complex vintage border designs\n   - Example CSS:\n     ```css\n     .section-divider-simple {\n       border-bottom: 2px solid var(--color-text);\n       margin: 2rem 0;\n     }\n     \n     .section-divider-double {\n       height: 4px;\n       border-top: 1px solid var(--color-text);\n       border-bottom: 1px solid var(--color-text);\n       margin: 2rem 0;\n     }\n     \n     .section-divider-decorative {\n       height: 10px;\n       background-image: url('/assets/images/vintage-border.svg');\n       background-repeat: repeat-x;\n       margin: 2rem 0;\n     }\n     ```\n\n4. Create Torn Paper Edge Effects:\n   - Implement torn/ripped paper edge effects using CSS clip-path and SVG filters\n   - Create both top and bottom torn edge variations\n   - Ensure the effect works responsively across different screen sizes\n   - Example implementation:\n     ```css\n     .torn-edge-top {\n       position: relative;\n     }\n     \n     .torn-edge-top::before {\n       content: \"\";\n       position: absolute;\n       top: -15px;\n       left: 0;\n       width: 100%;\n       height: 15px;\n       background-image: url('/assets/images/torn-edge-top.svg');\n       background-repeat: repeat-x;\n     }\n     \n     /* Alternative CSS clip-path approach */\n     .torn-edge-bottom {\n       clip-path: polygon(\n         0% 0%, 5% 100%, 10% 98%, 15% 100%, 20% 98%, 25% 100%, \n         30% 98%, 35% 100%, 40% 98%, 45% 100%, 50% 98%, 55% 100%, \n         60% 98%, 65% 100%, 70% 98%, 75% 100%, 80% 98%, 85% 100%, \n         90% 98%, 95% 100%, 100% 98%, 100% 0%\n       );\n     }\n     ```\n\n5. Create SVG Filter for Aged Paper Texture:\n   - Implement SVG filters to add subtle texture to components\n   - Create a reusable filter that can be applied to any component\n   - Example SVG filter:\n     ```html\n     <svg style=\"display: none;\">\n       <filter id=\"paper-texture\">\n         <feTurbulence type=\"fractalNoise\" baseFrequency=\"0.04\" numOctaves=\"5\" seed=\"1\" />\n         <feDisplacementMap in=\"SourceGraphic\" scale=\"5\" />\n         <feColorMatrix type=\"matrix\" values=\"1 0 0 0 0\n                                              0 1 0 0 0\n                                              0 0 1 0 0\n                                              0 0 0 0.1 0\" />\n       </filter>\n     </svg>\n     ```\n\n6. Document Component Usage:\n   - Create a documentation file explaining how to use each component\n   - Include examples of component combinations for common newspaper layouts\n   - Add notes about accessibility considerations for each component",
        "testStrategy": "1. Visual Component Testing:\n   - Create a test page that displays all components in various configurations\n   - Verify that multi-column layouts maintain proper text flow and readability\n   - Check that the masthead header displays correctly with all elements properly aligned\n   - Confirm that section dividers render with the expected styling and spacing\n   - Verify that torn paper edge effects appear realistic and consistent\n\n2. Responsive Testing:\n   - Test all components across multiple device sizes (mobile, tablet, desktop)\n   - Verify that multi-column layouts properly collapse on smaller screens\n   - Confirm that torn paper edges scale appropriately without distortion\n   - Check that the masthead remains legible and properly formatted at all breakpoints\n\n3. Cross-Browser Compatibility:\n   - Test all components in Chrome, Firefox, Safari, and Edge\n   - Pay special attention to SVG filters and clip-path implementations\n   - Document any browser-specific fallbacks or polyfills needed\n\n4. Performance Testing:\n   - Measure rendering performance of complex components (especially SVG filters)\n   - Optimize any components that cause noticeable performance issues\n   - Verify that page load times remain acceptable with all components in use\n\n5. Accessibility Testing:\n   - Ensure all components maintain proper contrast ratios using the newspaper color palette\n   - Verify that text remains readable in multi-column layouts\n   - Check that screen readers can properly navigate the content structure\n   - Test keyboard navigation through all interactive components\n\n6. Integration Testing:\n   - Implement components in at least three different page templates\n   - Verify that components work correctly when combined with each other\n   - Check that components respect the typography system from Task #1\n   - Confirm that components use the color variables from Task #2",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Halftone Dot Patterns and Newspaper Textures",
        "description": "Create and implement CSS background patterns for halftone dots, subtle paper texture overlays, ink bleed effects for text, and vintage printing artifacts to enhance the newspaper's authentic appearance.",
        "details": "1. Create Halftone Dot Pattern Backgrounds:\n   - Implement CSS patterns using radial gradients or SVG patterns for halftone dot effects\n   - Create at least three variations of dot density and size for different sections\n   - Example implementation:\n     ```css\n     .halftone-background-light {\n       background-image: radial-gradient(#1A1A1A 1px, transparent 1px);\n       background-size: 10px 10px;\n       background-color: var(--color-background);\n     }\n     \n     .halftone-background-medium {\n       background-image: radial-gradient(#1A1A1A 1.5px, transparent 1.5px);\n       background-size: 8px 8px;\n       background-color: var(--color-background);\n     }\n     ```\n\n2. Add Paper Texture Overlays:\n   - Create subtle paper texture using CSS or optimized SVG patterns\n   - Apply texture as a semi-transparent overlay on content sections\n   - Ensure texture enhances readability without compromising it\n   - Example implementation:\n     ```css\n     .paper-texture {\n       position: relative;\n     }\n     \n     .paper-texture::after {\n       content: \"\";\n       position: absolute;\n       top: 0;\n       left: 0;\n       width: 100%;\n       height: 100%;\n       background-image: url('/assets/images/textures/paper-grain.png');\n       opacity: 0.08;\n       pointer-events: none;\n       z-index: 1;\n     }\n     ```\n\n3. Implement Ink Bleed Effects for Text:\n   - Create CSS classes for text with subtle ink bleeding appearance\n   - Use text-shadow and/or SVG filters to simulate ink absorption into paper\n   - Apply to headlines and important text elements\n   - Example implementation:\n     ```css\n     .ink-bleed-text {\n       text-shadow: 0 0 1px rgba(26, 26, 26, 0.3);\n       letter-spacing: 0.02em;\n     }\n     \n     .ink-bleed-headline {\n       filter: url('#ink-bleed-filter');\n       letter-spacing: 0.03em;\n     }\n     ```\n   - Add corresponding SVG filter definition to the document:\n     ```html\n     <svg style=\"display: none;\">\n       <filter id=\"ink-bleed-filter\">\n         <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"0.2\" result=\"blur\" />\n         <feColorMatrix in=\"blur\" mode=\"matrix\" values=\"1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7\" result=\"inkBleed\" />\n         <feComposite in=\"SourceGraphic\" in2=\"inkBleed\" operator=\"over\" />\n       </filter>\n     </svg>\n     ```\n\n4. Create Vintage Printing Artifacts:\n   - Develop CSS classes for misaligned print effects (slight offset shadows)\n   - Create ink spatter/smudge decorative elements using SVG or PNG assets\n   - Add subtle paper fold/crease effects for section dividers\n   - Example implementation:\n     ```css\n     .misaligned-print {\n       position: relative;\n     }\n     \n     .misaligned-print::before {\n       content: attr(data-text);\n       position: absolute;\n       top: 0.5px;\n       left: -0.5px;\n       color: var(--color-text);\n       opacity: 0.4;\n       z-index: -1;\n     }\n     ```\n\n5. Integrate All Effects into Component System:\n   - Create utility classes that can be applied to existing components\n   - Ensure all effects work with the existing typography and color system\n   - Document usage guidelines for when each effect should be applied\n   - Create mixins or helper functions for customizing effect intensity",
        "testStrategy": "1. Visual Inspection Testing:\n   - Create a test page showcasing all texture and pattern effects\n   - Verify halftone patterns display correctly at different screen sizes\n   - Confirm paper texture overlays enhance rather than detract from readability\n   - Check that ink bleed effects appear authentic without compromising text clarity\n   - Ensure vintage printing artifacts add character without appearing excessive\n\n2. Cross-browser Compatibility Testing:\n   - Test all effects in Chrome, Firefox, Safari, and Edge\n   - Verify SVG filters render consistently across browsers\n   - Check performance impact of texture overlays on page rendering\n   - Ensure fallbacks work properly in browsers with limited CSS support\n\n3. Performance Testing:\n   - Measure impact of texture overlays on page load time\n   - Optimize any image assets used for textures (compression, dimensions)\n   - Verify scrolling performance isn't degraded by complex CSS effects\n   - Test on lower-end devices to ensure acceptable performance\n\n4. Accessibility Testing:\n   - Verify text remains readable with all effects applied\n   - Check contrast ratios meet WCAG standards despite texture overlays\n   - Ensure screen readers can properly access content with effects applied\n   - Test with different zoom levels to ensure readability is maintained\n\n5. Integration Testing:\n   - Apply effects to existing layout components from Task 3\n   - Verify compatibility with typography system from Task 1\n   - Confirm effects work harmoniously with color palette from Task 2\n   - Test combinations of effects to ensure they don't conflict visually",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate Comic Strip Visual Elements",
        "description": "Transform concept cards into comic panels with black borders, add speech bubbles for user feedback, create thought clouds for loading states, and implement comic-style POW/BAM effects for key interactions.",
        "details": "1. Create Comic Panel Containers:\n   - Transform existing concept cards into comic-style panels with thick black borders\n   - Implement CSS for panel styling:\n     ```css\n     .comic-panel {\n       border: 3px solid #1A1A1A;\n       border-radius: 2px;\n       box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.2);\n       background-color: var(--color-background);\n       padding: 1rem;\n       margin-bottom: 1.5rem;\n     }\n     ```\n   - Create variations for different panel sizes and layouts (horizontal, vertical, inset)\n\n2. Implement Speech Bubble Components:\n   - Create reusable speech bubble components for user feedback messages\n   - Design at least three variations: standard speech, shouting, and whisper\n   - Implement with CSS:\n     ```css\n     .speech-bubble {\n       position: relative;\n       background: white;\n       border: 2px solid #1A1A1A;\n       border-radius: 1rem;\n       padding: 0.75rem 1rem;\n       margin: 1rem 0;\n     }\n     \n     .speech-bubble:after {\n       content: '';\n       position: absolute;\n       bottom: -15px;\n       left: 20px;\n       border-width: 15px 15px 0;\n       border-style: solid;\n       border-color: white transparent;\n     }\n     \n     .speech-bubble:before {\n       content: '';\n       position: absolute;\n       bottom: -18px;\n       left: 18px;\n       border-width: 17px 17px 0;\n       border-style: solid;\n       border-color: #1A1A1A transparent;\n     }\n     ```\n   - Create React/Vue component that wraps feedback messages in appropriate bubble style\n\n3. Design Thought Cloud Components for Loading States:\n   - Replace standard loading spinners with comic-style thought clouds\n   - Implement animated ellipsis inside thought bubbles\n   - Create CSS for thought cloud styling:\n     ```css\n     .thought-cloud {\n       position: relative;\n       background: white;\n       border: 2px solid #1A1A1A;\n       border-radius: 50%;\n       padding: 1rem;\n     }\n     \n     .thought-cloud:before, .thought-cloud:after {\n       content: '';\n       position: absolute;\n       background: white;\n       border: 2px solid #1A1A1A;\n       border-radius: 50%;\n     }\n     \n     .thought-cloud:before {\n       width: 20px;\n       height: 20px;\n       bottom: -10px;\n       left: 20px;\n     }\n     \n     .thought-cloud:after {\n       width: 10px;\n       height: 10px;\n       bottom: -20px;\n       left: 30px;\n     }\n     ```\n   - Add loading animation using CSS keyframes\n\n4. Create Comic-Style Effect Overlays:\n   - Implement POW/BAM/ZOOM effect components for key interactions\n   - Design SVG assets for each effect type\n   - Create animation sequences for dramatic entrances/exits\n   - Implement with CSS and JavaScript:\n     ```css\n     .comic-effect {\n       position: absolute;\n       z-index: 100;\n       transform-origin: center;\n       animation: comic-effect-animation 0.5s ease-out forwards;\n     }\n     \n     @keyframes comic-effect-animation {\n       0% { transform: scale(0); opacity: 0; }\n       50% { transform: scale(1.2); opacity: 1; }\n       100% { transform: scale(1); opacity: 1; }\n     }\n     ```\n   - Create a JavaScript utility function to trigger effects at specific interaction points\n\n5. Integrate Comic Elements with Existing Components:\n   - Update notification system to use speech bubbles\n   - Replace loading indicators with thought clouds\n   - Add POW/BAM effects to form submissions, successful actions, and error states\n   - Ensure all comic elements maintain proper alignment with the newspaper layout",
        "testStrategy": "1. Visual Component Testing:\n   - Create a dedicated test page showcasing all comic elements in isolation\n   - Verify that comic panels render correctly with proper borders and shadows\n   - Confirm that speech bubbles display correctly with tails pointing in the right direction\n   - Check that thought clouds animate properly during loading states\n   - Verify POW/BAM effects appear and animate correctly\n\n2. Integration Testing:\n   - Test comic panels in various layout configurations (single column, multi-column)\n   - Verify speech bubbles correctly wrap different lengths of text without breaking layout\n   - Test thought cloud loading states with different loading durations\n   - Confirm POW/BAM effects trigger at appropriate interaction points\n   - Verify all comic elements work correctly with the newspaper color palette\n\n3. Responsive Design Testing:\n   - Check that comic elements scale appropriately on mobile, tablet, and desktop views\n   - Verify speech bubbles and thought clouds remain readable at all screen sizes\n   - Confirm that POW/BAM effects don't overflow or cause layout issues on small screens\n\n4. Accessibility Testing:\n   - Ensure comic elements maintain proper contrast ratios for readability\n   - Verify that animations can be disabled via prefers-reduced-motion media query\n   - Confirm that screen readers can properly interpret content within comic elements\n   - Test keyboard navigation through interactive comic elements\n\n5. Browser Compatibility Testing:\n   - Verify comic elements render correctly in Chrome, Firefox, Safari, and Edge\n   - Check that animations work consistently across browsers\n   - Confirm that CSS features used in comic elements have appropriate fallbacks",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Newspaper-Themed Animations",
        "description": "Create and implement a set of newspaper-themed animations including typewriter effect for headlines, paper flip transitions between sections, printing press loading states, ink stamp selection animations, and paper crumple deletion effects.",
        "details": "1. Implement Typewriter Effect for Headlines:\n   - Create a JavaScript utility function that reveals text character by character\n   - Apply to all headline elements (h1, h2) when they enter the viewport\n   - Add subtle cursor blinking effect during typing\n   - Include timing parameters for speed adjustment\n   - Example implementation:\n     ```javascript\n     function typewriterEffect(element, text, speed = 50) {\n       let i = 0;\n       element.textContent = '';\n       const timer = setInterval(() => {\n         if (i < text.length) {\n           element.textContent += text.charAt(i);\n           i++;\n         } else {\n           clearInterval(timer);\n           element.classList.add('typing-complete');\n         }\n       }, speed);\n     }\n     ```\n\n2. Create Paper Flip Transitions:\n   - Implement CSS animations for page transition effects between sections\n   - Use CSS transform properties to create 3D page turning effect\n   - Add subtle paper texture movement during transitions\n   - Ensure smooth animation with proper easing functions\n   - Example implementation:\n     ```css\n     .page-transition {\n       perspective: 1000px;\n     }\n     \n     .page-transition .page {\n       transform-origin: left center;\n       transition: transform 0.6s cubic-bezier(0.645, 0.045, 0.355, 1);\n       backface-visibility: hidden;\n     }\n     \n     .page-transition.active .page {\n       transform: rotateY(-180deg);\n     }\n     ```\n\n3. Develop Printing Press Loading Animation:\n   - Create a custom loading spinner that resembles a printing press roller\n   - Implement using CSS animations or SVG animations\n   - Add ink spreading effect as the roller moves\n   - Ensure animation is lightweight and performant\n   - Example implementation:\n     ```css\n     @keyframes printing-press {\n       0% { transform: translateY(0) rotate(0deg); }\n       50% { transform: translateY(10px) rotate(180deg); }\n       100% { transform: translateY(0) rotate(360deg); }\n     }\n     \n     .loading-press {\n       width: 60px;\n       height: 60px;\n       border-radius: 30px;\n       background: var(--color-text);\n       animation: printing-press 1.5s infinite ease-in-out;\n     }\n     ```\n\n4. Create Ink Stamp Selection Animations:\n   - Implement animation for when users select or click on interactive elements\n   - Add ink splatter effect that radiates from the point of interaction\n   - Use SVG masks or CSS clip-path for irregular ink splatter shapes\n   - Ensure animation is quick and responsive\n   - Example implementation:\n     ```javascript\n     function createInkStampEffect(event) {\n       const stampElement = document.createElement('div');\n       stampElement.classList.add('ink-stamp');\n       stampElement.style.left = `${event.clientX}px`;\n       stampElement.style.top = `${event.clientY}px`;\n       document.body.appendChild(stampElement);\n       \n       // Remove after animation completes\n       setTimeout(() => {\n         stampElement.remove();\n       }, 1000);\n     }\n     ```\n\n5. Implement Paper Crumple Delete Effect:\n   - Create animation for when items are deleted or removed\n   - Use CSS transforms to simulate paper crumpling\n   - Add subtle sound effect option for enhanced feedback\n   - Ensure animation completes quickly to not delay UI updates\n   - Example implementation:\n     ```css\n     @keyframes crumple {\n       0% { transform: scale(1); opacity: 1; }\n       50% { transform: scale(0.5) rotate(10deg); opacity: 0.5; }\n       100% { transform: scale(0) rotate(25deg); opacity: 0; }\n     }\n     \n     .delete-animation {\n       animation: crumple 0.4s forwards ease-in;\n     }\n     ```\n\n6. Optimize Animation Performance:\n   - Use requestAnimationFrame for JavaScript animations\n   - Leverage CSS will-change property for elements that will animate\n   - Ensure animations don't trigger layout thrashing\n   - Implement animation throttling on lower-end devices\n   - Test performance impact and adjust as needed\n\n7. Create Animation Toggle System:\n   - Implement user preference setting to reduce or disable animations\n   - Add data attributes to control animation presence\n   - Create fallback states for when animations are disabled\n   - Store preference in localStorage for persistence",
        "testStrategy": "1. Visual Testing:\n   - Create a dedicated test page showcasing all animations in isolation\n   - Verify each animation renders correctly across different browsers (Chrome, Firefox, Safari, Edge)\n   - Check animations on both desktop and mobile devices\n   - Confirm animations work at different screen sizes and resolutions\n\n2. Performance Testing:\n   - Use Chrome DevTools Performance panel to measure animation frame rates\n   - Verify animations maintain 60fps on target devices\n   - Check CPU and memory usage during animations\n   - Test on lower-end devices to ensure acceptable performance\n   - Identify and fix any animations causing jank or stuttering\n\n3. Accessibility Testing:\n   - Verify animations respect user's prefers-reduced-motion settings\n   - Ensure animations don't cause issues for screen readers\n   - Test keyboard navigation during animations\n   - Confirm animations don't create seizure risks (no rapid flashing)\n\n4. Functional Testing:\n   - Verify typewriter effect correctly reveals all text without cutting off characters\n   - Confirm paper flip transitions properly show new content after animation completes\n   - Test loading animations appear and disappear at appropriate times\n   - Verify ink stamp effects trigger on all interactive elements\n   - Check that delete animations complete fully before elements are removed from DOM\n\n5. Integration Testing:\n   - Test animations in the context of the full application\n   - Verify animations don't interfere with other UI components\n   - Check that multiple simultaneous animations don't conflict\n   - Confirm animations work correctly when navigating through the application flow\n\n6. User Testing:\n   - Gather feedback on animation timing and feel\n   - Adjust animation speed and easing based on user feedback\n   - Verify animations enhance rather than detract from user experience",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          5
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Redesign LocationDetector Component with Editorial Newspaper Theme",
        "description": "Transform the LocationDetector component to match the newspaper editorial theme by styling it as a vintage newspaper search box with typewriter font, adding a \"BREAKING NEWS FROM:\" label, implementing a vintage map pin icon, and creating a newspaper clipping style for saved location displays.",
        "details": "1. Modify the LocationDetector Search Box:\n   - Style the search input to resemble a vintage newspaper search box\n   - Apply Courier Prime font (from Task 1) to the input field for typewriter appearance\n   - Add a subtle paper texture background (from Task 4)\n   - Implement CSS for the search box:\n     ```css\n     .location-search {\n       font-family: 'Courier Prime', monospace;\n       background-color: var(--color-background);\n       border: 1px solid var(--color-text);\n       padding: 0.75rem;\n       width: 100%;\n       box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);\n     }\n     ```\n\n2. Create \"BREAKING NEWS FROM:\" Label:\n   - Add a prominent label above the search box\n   - Style using Playfair Display font (from Task 1) in all caps\n   - Apply editorial red color (from Task 2) for emphasis\n   - Implement the label with appropriate HTML/CSS:\n     ```html\n     <div class=\"breaking-news-label\">BREAKING NEWS FROM:</div>\n     ```\n     ```css\n     .breaking-news-label {\n       font-family: 'Playfair Display', serif;\n       font-weight: bold;\n       color: var(--color-accent);\n       font-size: 1.2rem;\n       margin-bottom: 0.5rem;\n       letter-spacing: 0.05em;\n     }\n     ```\n\n3. Implement Vintage Map Pin Icon:\n   - Create or source a vintage-style map pin SVG icon\n   - Replace the current location icon with the vintage version\n   - Position the icon appropriately within the search interface\n   - Implement with CSS for proper styling:\n     ```css\n     .vintage-map-pin {\n       fill: var(--color-accent);\n       width: 24px;\n       height: 24px;\n       vertical-align: middle;\n     }\n     ```\n\n4. Create Newspaper Clipping Style for Saved Locations:\n   - Design saved locations to appear as newspaper clippings\n   - Add torn paper edge effect using CSS (can leverage components from Task 3)\n   - Apply subtle rotation to each clipping for a more authentic look\n   - Implement halftone dot pattern background (from Task 4)\n   - Add CSS for the newspaper clipping effect:\n     ```css\n     .saved-location-clipping {\n       background-color: var(--color-background);\n       border: 1px solid var(--color-text);\n       padding: 1rem;\n       position: relative;\n       margin: 1rem 0;\n       box-shadow: 2px 2px 5px rgba(0,0,0,0.1);\n       transform: rotate(var(--random-rotation));\n     }\n     \n     .saved-location-clipping::before {\n       content: '';\n       position: absolute;\n       top: -5px;\n       left: 0;\n       right: 0;\n       height: 5px;\n       background-image: url('/assets/images/torn-edge.png');\n       background-repeat: repeat-x;\n     }\n     ```\n\n5. Integrate with Existing Theme Components:\n   - Ensure consistent use of the newspaper color palette (from Task 2)\n   - Apply appropriate typography from the newspaper system (from Task 1)\n   - Utilize multi-column layout for multiple saved locations (from Task 3)\n   - Add typewriter animation effect when displaying search results (from Task 6)\n\n6. Implement Responsive Behavior:\n   - Ensure the redesigned component works well on all screen sizes\n   - Adjust layout and typography for mobile devices\n   - Maintain readability and usability across viewports",
        "testStrategy": "1. Visual Appearance Testing:\n   - Verify that the search box has the appropriate typewriter font styling\n   - Confirm the \"BREAKING NEWS FROM:\" label appears correctly with proper typography and color\n   - Check that the vintage map pin icon displays properly and replaces the previous icon\n   - Validate that saved locations have the newspaper clipping appearance with torn edges\n\n2. Functional Testing:\n   - Test the search functionality to ensure it still works correctly with the new styling\n   - Verify that location detection works properly with the redesigned interface\n   - Confirm that saving locations creates properly styled newspaper clippings\n   - Test that multiple saved locations display correctly in the layout\n\n3. Responsive Design Testing:\n   - Test the component on various screen sizes (desktop, tablet, mobile)\n   - Verify that all elements remain readable and properly aligned across devices\n   - Confirm that the newspaper clipping style adapts appropriately to different viewports\n\n4. Integration Testing:\n   - Verify that the component integrates properly with the rest of the application\n   - Confirm that the newspaper theme is consistent with other themed components\n   - Test interactions between this component and other related components\n\n5. Browser Compatibility Testing:\n   - Test the redesigned component in multiple browsers (Chrome, Firefox, Safari, Edge)\n   - Verify that all styling and effects render correctly across browsers\n   - Check that fonts and textures load properly in all environments\n\n6. Accessibility Testing:\n   - Verify that the redesigned component maintains proper accessibility\n   - Confirm that color contrast meets WCAG standards\n   - Test with screen readers to ensure all elements are properly announced",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Transform NewsDisplay Component into Newspaper Columns Layout",
        "description": "Redesign the NewsDisplay component with a multi-column newspaper layout, style article cards as newspaper clippings with date stamps, add \"LATEST EDITION\" header, implement humor score as editorial rating stars, and enhance byline styling for sources.",
        "details": "1. Implement Multi-Column Layout for Articles:\n   - Utilize the multi-column layout components from Task 3\n   - Apply responsive column layout based on screen size:\n     ```css\n     .news-display {\n       display: grid;\n       grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n       gap: 1.5rem;\n     }\n     \n     @media (min-width: 768px) {\n       .news-display {\n         grid-template-columns: repeat(2, 1fr);\n       }\n     }\n     \n     @media (min-width: 1024px) {\n       .news-display {\n         grid-template-columns: repeat(3, 1fr);\n       }\n     }\n     ```\n   - Ensure proper text flow between columns with appropriate gutters\n\n2. Style Article Cards as Newspaper Clippings:\n   - Apply vintage newspaper styling to article cards:\n     ```css\n     .article-card {\n       background-color: var(--color-background);\n       border: 1px solid var(--color-text);\n       padding: 1rem;\n       box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.1);\n       position: relative;\n     }\n     \n     .article-card::after {\n       content: \"\";\n       position: absolute;\n       bottom: -5px;\n       right: -5px;\n       width: 100%;\n       height: 100%;\n       background-color: var(--color-background);\n       z-index: -1;\n       border: 1px solid var(--color-text);\n     }\n     ```\n   - Add torn paper edge effect using the techniques from Task 4\n   - Implement subtle paper texture overlay from Task 4\n\n3. Add Date Stamps to Articles:\n   - Create a date stamp component that displays the article publication date\n   - Style it as a vintage newspaper date stamp:\n     ```css\n     .date-stamp {\n       font-family: 'Courier Prime', monospace;\n       font-size: 0.8rem;\n       color: var(--color-accent);\n       border: 1px solid var(--color-accent);\n       border-radius: 2px;\n       padding: 0.2rem 0.5rem;\n       display: inline-block;\n       transform: rotate(-2deg);\n       position: absolute;\n       top: -10px;\n       right: 10px;\n       background-color: var(--color-background);\n     }\n     ```\n   - Format dates in newspaper style (e.g., \"JAN 15, 2023\")\n\n4. Implement \"LATEST EDITION\" Header:\n   - Create a masthead-style header at the top of the NewsDisplay component\n   - Use Playfair Display font (from Task 1) with appropriate sizing\n   - Add decorative elements like horizontal rules and vintage ornaments:\n     ```css\n     .latest-edition-header {\n       font-family: 'Playfair Display', serif;\n       font-size: 2.5rem;\n       font-weight: 900;\n       text-align: center;\n       margin-bottom: 2rem;\n       padding-bottom: 1rem;\n       border-bottom: 3px double var(--color-text);\n       position: relative;\n     }\n     \n     .latest-edition-header::before,\n     .latest-edition-header::after {\n       content: \"\";\n       font-size: 1.5rem;\n       position: absolute;\n       bottom: -0.5rem;\n       color: var(--color-accent);\n     }\n     \n     .latest-edition-header::before {\n       left: 25%;\n     }\n     \n     .latest-edition-header::after {\n       right: 25%;\n     }\n     ```\n   - Apply typewriter animation effect from Task 6 when the page loads\n\n5. Implement Humor Score as Editorial Rating Stars:\n   - Create a star rating component that displays humor scores\n   - Style stars to match the newspaper editorial theme:\n     ```css\n     .editorial-rating {\n       display: flex;\n       gap: 0.25rem;\n       margin: 0.5rem 0;\n     }\n     \n     .star {\n       width: 1rem;\n       height: 1rem;\n       fill: none;\n       stroke: var(--color-text);\n       stroke-width: 2;\n     }\n     \n     .star.filled {\n       fill: var(--color-accent);\n     }\n     ```\n   - Add \"Editorial Rating:\" label in Courier Prime font\n   - Implement JavaScript to convert numeric humor scores to star ratings:\n     ```javascript\n     function renderStarRating(container, score) {\n       const maxStars = 5;\n       const fullStars = Math.floor(score);\n       \n       for (let i = 0; i < maxStars; i++) {\n         const star = document.createElement('div');\n         star.classList.add('star');\n         if (i < fullStars) {\n           star.classList.add('filled');\n         }\n         container.appendChild(star);\n       }\n     }\n     ```\n\n6. Enhance Byline Styling for Sources:\n   - Create a newspaper-style byline for article sources\n   - Style using italic Crimson Text font (from Task 1):\n     ```css\n     .article-byline {\n       font-family: 'Crimson Text', serif;\n       font-style: italic;\n       font-size: 0.9rem;\n       color: var(--color-text);\n       margin-top: 0.5rem;\n       border-top: 1px solid rgba(26, 26, 26, 0.2);\n       padding-top: 0.5rem;\n     }\n     ```\n   - Prefix sources with \"By:\" or \"Source:\"\n   - Add small newspaper icon before the source name\n\n7. Integrate with Existing Components:\n   - Ensure compatibility with the comic strip visual elements from Task 5\n   - Apply newspaper-themed animations from Task 6 for transitions between articles\n   - Use the color palette from Task 2 consistently throughout the component",
        "testStrategy": "1. Visual Component Testing:\n   - Create a dedicated test page that displays the NewsDisplay component with various article configurations\n   - Verify that the multi-column layout renders correctly across different screen sizes\n   - Confirm that article cards have the newspaper clipping style with proper shadows and borders\n   - Check that date stamps are positioned correctly and formatted in newspaper style\n   - Ensure the \"LATEST EDITION\" header displays with all decorative elements\n\n2. Responsive Layout Testing:\n   - Test the component on multiple devices and screen sizes (mobile, tablet, desktop)\n   - Verify that columns adjust appropriately based on screen width\n   - Confirm that article cards maintain readability at all screen sizes\n   - Check that spacing and proportions remain consistent across devices\n\n3. Functionality Testing:\n   - Verify that humor scores correctly convert to star ratings\n   - Test with different score values (0, 2.5, 5) to ensure proper star rendering\n   - Confirm that bylines display correctly with source information\n   - Test with various article data to ensure the layout handles different content lengths\n\n4. Integration Testing:\n   - Verify that the NewsDisplay component works correctly with the rest of the application\n   - Test navigation between the NewsDisplay and other components\n   - Confirm that animations and transitions work as expected\n   - Check that the component properly fetches and displays article data\n\n5. Accessibility Testing:\n   - Verify that all text maintains sufficient contrast against background colors\n   - Ensure that star ratings have appropriate ARIA attributes for screen readers\n   - Test keyboard navigation through the article grid\n   - Confirm that the component is usable with screen readers\n\n6. Cross-Browser Testing:\n   - Test the component in multiple browsers (Chrome, Firefox, Safari, Edge)\n   - Verify that all styling and layout features render consistently\n   - Check that animations work properly across different browsers\n   - Confirm that the newspaper texture and halftone effects display correctly",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Article Styling with Newspaper Clipping Effects",
        "description": "Create detailed newspaper clipping styling for article components with torn edges, date stamps, headline typography, and source attribution that enhances the editorial newspaper theme.",
        "details": "1. Create Newspaper Clipping Container Component:\n   - Implement a reusable component for wrapping article content\n   - Add CSS for realistic torn paper edges using clip-path or SVG masks\n   - Apply subtle shadow effects to create depth perception\n   - Example implementation:\n     ```css\n     .newspaper-clipping {\n       position: relative;\n       background-color: var(--color-background);\n       padding: 1.5rem;\n       box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.15);\n       overflow: hidden;\n     }\n     \n     .newspaper-clipping::before {\n       content: '';\n       position: absolute;\n       top: 0;\n       left: 0;\n       right: 0;\n       bottom: 0;\n       background-color: var(--color-background);\n       clip-path: polygon(\n         0% 5%, 2% 0%, 5% 3%, 8% 1%, 12% 0%, 15% 2%, 18% 0%, 22% 1%, 25% 0%, 28% 2%, 30% 0%, 33% 3%, 36% 0%, 40% 2%, 44% 0%, 48% 1%, 52% 0%, 55% 2%, 58% 0%, 62% 1%, 65% 0%, 68% 2%, 72% 0%, 75% 1%, 78% 0%, 82% 2%, 85% 0%, 88% 1%, 92% 0%, 95% 2%, 98% 0%, 100% 5%, 100% 95%, 98% 100%, 95% 97%, 92% 100%, 88% 99%, 85% 100%, 82% 98%, 78% 100%, 75% 99%, 72% 100%, 68% 98%, 65% 100%, 62% 99%, 58% 100%, 55% 98%, 52% 100%, 48% 99%, 44% 100%, 40% 98%, 36% 100%, 33% 97%, 30% 100%, 28% 98%, 25% 100%, 22% 99%, 18% 100%, 15% 98%, 12% 100%, 8% 99%, 5% 97%, 2% 100%, 0% 95%\n       );\n       z-index: -1;\n     }\n     ```\n\n2. Implement Article Date Stamp:\n   - Create a diagonal date stamp component for articles\n   - Style with a faded red ink appearance using CSS\n   - Position in the top-right corner of article clippings\n   - Example implementation:\n     ```css\n     .date-stamp {\n       position: absolute;\n       top: 10px;\n       right: 20px;\n       transform: rotate(15deg);\n       font-family: 'Courier Prime', monospace;\n       color: var(--color-accent);\n       opacity: 0.8;\n       font-size: 0.9rem;\n       border: 1px solid var(--color-accent);\n       padding: 0.25rem 0.5rem;\n       border-radius: 3px;\n     }\n     ```\n\n3. Enhance Article Headline Typography:\n   - Apply Playfair Display font (from Task 1) to article headlines\n   - Implement proper newspaper headline styling with appropriate sizing and spacing\n   - Add subtle ink bleed effect for headlines using text-shadow\n   - Example implementation:\n     ```css\n     .article-headline {\n       font-family: 'Playfair Display', serif;\n       font-weight: 700;\n       font-size: 1.5rem;\n       line-height: 1.2;\n       margin-bottom: 0.75rem;\n       text-transform: uppercase;\n       letter-spacing: -0.5px;\n       text-shadow: 0px 0px 1px rgba(26, 26, 26, 0.5);\n     }\n     ```\n\n4. Create Source Attribution Styling:\n   - Implement byline styling for article sources\n   - Add vintage newspaper-style attribution line with italics\n   - Include small decorative elements like a small line or dot separator\n   - Example implementation:\n     ```css\n     .article-source {\n       font-family: 'Crimson Text', serif;\n       font-style: italic;\n       font-size: 0.9rem;\n       color: var(--color-text);\n       opacity: 0.8;\n       margin-top: 1rem;\n       padding-top: 0.5rem;\n       border-top: 1px dotted var(--color-text);\n     }\n     ```\n\n5. Add Vintage Newspaper Content Styling:\n   - Style article content text with proper newspaper column formatting\n   - Implement drop caps for the first letter of articles\n   - Add proper paragraph spacing and indentation\n   - Example implementation:\n     ```css\n     .article-content {\n       font-family: 'Crimson Text', serif;\n       font-size: 1rem;\n       line-height: 1.5;\n     }\n     \n     .article-content p {\n       text-indent: 1.5rem;\n       margin-bottom: 0.75rem;\n     }\n     \n     .article-content p:first-of-type::first-letter {\n       font-family: 'Playfair Display', serif;\n       font-size: 3rem;\n       float: left;\n       line-height: 0.8;\n       margin-right: 0.5rem;\n     }\n     ```\n\n6. Implement Yellowed Paper Effect:\n   - Create a subtle gradient overlay to simulate aged newspaper\n   - Add slight color variations to enhance the vintage appearance\n   - Example implementation:\n     ```css\n     .yellowed-paper {\n       position: relative;\n     }\n     \n     .yellowed-paper::after {\n       content: '';\n       position: absolute;\n       top: 0;\n       left: 0;\n       right: 0;\n       bottom: 0;\n       background: linear-gradient(135deg, rgba(255, 230, 109, 0.05), rgba(255, 230, 109, 0.1), rgba(255, 230, 109, 0.05));\n       pointer-events: none;\n     }\n     ```\n\n7. Integrate with Existing Components:\n   - Apply these styles to the article components in the NewsDisplay\n   - Ensure compatibility with the multi-column layout from Task 3\n   - Make all styling responsive for different screen sizes",
        "testStrategy": "1. Visual Appearance Testing:\n   - Create a dedicated test page with multiple article clippings in various states\n   - Verify that torn paper edges render correctly across different browsers\n   - Confirm that date stamps are properly positioned and styled\n   - Check that headline typography matches newspaper editorial style\n   - Ensure source attribution styling is consistent and readable\n\n2. Responsive Design Testing:\n   - Test article clipping appearance across multiple device sizes (mobile, tablet, desktop)\n   - Verify that torn edges scale appropriately without breaking the design\n   - Confirm that typography remains readable at all screen sizes\n   - Check that date stamps remain visible but don't overwhelm the design on small screens\n\n3. Browser Compatibility Testing:\n   - Test in Chrome, Firefox, Safari, and Edge to ensure consistent rendering\n   - Verify that clip-path and other advanced CSS features have appropriate fallbacks\n   - Check that text rendering and shadows appear consistent across browsers\n\n4. Integration Testing:\n   - Verify that article styling works correctly within the NewsDisplay component\n   - Confirm compatibility with the multi-column layout from Task 3\n   - Test that articles maintain proper styling when dynamically loaded\n   - Ensure that styling doesn't conflict with existing component functionality\n\n5. Performance Testing:\n   - Measure rendering performance with multiple article clippings on the page\n   - Verify that CSS animations and effects don't cause performance issues\n   - Check that page load time isn't significantly impacted by the styling\n\n6. Accessibility Testing:\n   - Verify that text remains readable with the newspaper styling applied\n   - Confirm that color contrast meets WCAG standards\n   - Check that decorative elements don't interfere with screen readers",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          8
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-15T12:56:47.850Z",
      "updated": "2025-11-15T13:50:14.325Z",
      "description": "Complete UI redesign implementing Editorial Newspaper aesthetic with comic elements"
    }
  },
  "news-source-filtering": {
    "tasks": [
      {
        "id": 1,
        "title": "Design and Implement a Location-to-News-Source Data Structure",
        "description": "Develop a data structure that leverages Google News's built-in authority ranking to identify top mainstream news sources for major world cities, storing source names, domain names, and authority rankings for filtering and display.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "1. Implement a strategy that leverages Google News RSS's built-in authority ranking (using the 'scoring=r' parameter) which already prioritizes authoritative sources for each location.\n\n2. For each city (Melbourne, Sydney, Brisbane, Perth, Adelaide, Canberra, New York, Los Angeles, Chicago, San Francisco, London, Manchester, and other major world cities), capture the first 5-10 Google News results as these represent the most authoritative sources for that location.\n\n3. For each news source, collect the display name (e.g., 'The Age'), the canonical domain name (e.g., 'theage.com.au'), and add a position indicator (1st = most authoritative, 2nd = second most authoritative, etc.) based on Google News ranking.\n\n4. Design the data structure for efficient lookup and filtering. Recommended best practice is to use a nested dictionary or map, where the top-level key is the city name (normalized), and the value is a list of objects containing 'sourceName', 'domain', and 'authorityRank'. For example:\n\n```json\n{\n  \"Melbourne\": [\n    { \"sourceName\": \"The Age\", \"domain\": \"theage.com.au\", \"authorityRank\": 1 },\n    ...\n  ],\n  ...\n}\n```\n\n5. Store the data in a format suitable for both backend (e.g., JSON, YAML) and frontend consumption. Ensure the structure is extensible for future cities or sources.\n\n6. Document the data schema and provide clear guidelines for updating or extending the list. Consider internationalization and encoding issues for non-English city/source names.\n\n7. Include unit tests or validation scripts to check for missing fields, duplicate domains, and correct mapping.",
        "testStrategy": "1. Verify that each specified city is present in the data structure and mapped to at least 5 authoritative news sources.\n\n2. For each source, confirm that 'sourceName', 'domain', and 'authorityRank' fields are present, non-empty, and correctly formatted.\n\n3. Run automated scripts to check for duplicate domains within and across cities.\n\n4. Validate that the sources are properly ranked according to Google News results (1st position = highest authority).\n\n5. Test that the data structure can be loaded and queried efficiently in both backend and frontend environments.\n\n6. Verify the structure supports filtering by authority rank (e.g., only showing top 3 sources).\n\n7. Test extensibility by adding a new city and verifying the update process is straightforward and error-free.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Google News RSS Authority Ranking Strategy",
            "description": "Develop a method to query Google News RSS with the 'scoring=r' parameter for each major city to obtain the most authoritative news sources based on Google's built-in ranking algorithm.",
            "status": "done",
            "dependencies": [],
            "details": "Create a script that queries Google News RSS feeds for each target city (Melbourne, Sydney, Brisbane, Perth, Adelaide, Canberra, New York, Los Angeles, Chicago, San Francisco, London, Manchester, and other major world cities) using the 'scoring=r' parameter. Extract the first 5-10 results for each location as these represent the most authoritative sources according to Google's algorithm.",
            "testStrategy": "Verify that the script successfully retrieves Google News RSS results for each city, and that the 'scoring=r' parameter is correctly applied to prioritize authoritative sources."
          },
          {
            "id": 2,
            "title": "Extract and Normalize News Source Data with Authority Rankings",
            "description": "For each news source identified from Google News results, extract the display name, canonical domain, and add an authority rank based on its position in the Google News results.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Process the Google News results to extract source information. For each result, capture the 'sourceName' (e.g., 'The Age'), the 'domain' (e.g., 'theage.com.au'), and assign an 'authorityRank' based on its position in the results (1st position = rank 1, 2nd position = rank 2, etc.). Normalize domains to lowercase and ensure all fields are properly formatted.",
            "testStrategy": "Run validation scripts to check that each source has a valid name, domain, and authority rank. Verify that authority ranks correctly reflect the order of sources in Google News results."
          },
          {
            "id": 3,
            "title": "Design and Implement the Location-to-News-Source Data Structure",
            "description": "Design a data structure for efficient lookup and filtering, mapping normalized city names to lists of news source objects containing 'sourceName', 'domain', and 'authorityRank'. Implement the structure in a format suitable for backend and frontend use.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Use a nested dictionary or map, with the top-level key as the normalized city name and the value as a list of objects. Each object should contain 'sourceName', 'domain', and 'authorityRank' fields. Ensure the structure is extensible for future cities or sources and supports both JSON and YAML serialization.",
            "testStrategy": "Test lookup and filtering performance, and verify that the structure supports addition of new cities and sources without breaking existing mappings. Test filtering by authority rank."
          },
          {
            "id": 4,
            "title": "Document Data Schema and Update Guidelines",
            "description": "Create comprehensive documentation for the data schema, including field definitions, normalization rules, and clear guidelines for updating or extending the list. Address internationalization and encoding for non-English names.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Provide schema definitions, example entries, and step-by-step instructions for adding new cities or sources. Include notes on handling non-English characters and encoding issues. Document the Google News RSS authority ranking approach and how to refresh the data periodically.",
            "testStrategy": "Review documentation for completeness and clarity. Have a third party follow the guidelines to add a new city and verify correctness."
          },
          {
            "id": 5,
            "title": "Implement Automated Validation and Testing Scripts",
            "description": "Develop unit tests and validation scripts to check for missing fields, duplicate domains, correct mappings, and proper authority rankings. Include tests for filtering by authority rank.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Scripts should validate the integrity of the data structure, ensure all required fields are present and correctly formatted, and verify that authority rankings are consistent with Google News result positions. Test filtering capabilities to ensure users can limit results by authority rank (e.g., only top 3 sources).",
            "testStrategy": "Achieve >90% test coverage for validation logic. Run tests on the full data set and confirm that all errors and inconsistencies are flagged and can be resolved efficiently."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement News Source Filtering and Ranking Logic in newsService.ts",
        "description": "Develop robust filtering and ranking logic in newsService.ts to process news articles based on a configurable mainstream sources mapping, supporting both strict and soft filtering modes.",
        "details": "1. **Domain Extraction**: Implement a utility method to reliably extract the canonical domain from article URLs, handling common edge cases (e.g., subdomains, tracking parameters, internationalized domains). Use established libraries (such as the 'tldts' or 'psl' npm packages) for accuracy and maintainability.\n\n2. **Mainstream Source Matching**: Integrate the city-to-mainstream-sources mapping (from Task 1) and implement a method to check if an article's domain matches any whitelisted mainstream domains for the relevant city. Ensure case-insensitive and normalized matching.\n\n3. **Filtering Modes**:\n   - **Strict Filtering**: Only include articles from whitelisted mainstream sources.\n   - **Soft Ranking**: Return all articles, but rank those from mainstream sources higher. Implement a ranking function that prioritizes mainstream sources, optionally using a secondary sort by source prominence (e.g., order in the mapping or external traffic rank if available).\n   - Add a configuration option (e.g., in a config file or environment variable) to toggle between strict and soft modes at runtime.\n\n4. **No Mainstream Sources Handling**: If no articles from mainstream sources are found, return a fallback list of non-mainstream articles, clearly flagged in the response. Optionally, log or track these cases for analytics.\n\n5. **Extensibility and Testing**: Structure the code for easy extension (e.g., supporting additional filtering criteria or ranking signals in the future). Write clear JSDoc comments and ensure all methods are unit-testable.\n\n6. **Best Practices**: Follow SOLID principles, keep filtering logic isolated from data-fetching, and use dependency injection for configuration and source mappings. Ensure all code is TypeScript-typed for safety and maintainability.",
        "testStrategy": "1. **Unit Tests**: Write comprehensive unit tests for domain extraction, including edge cases (e.g., www prefixes, subdomains, international domains).\n\n2. **Source Matching**: Test that articles from whitelisted domains are correctly identified as mainstream, and that non-mainstream articles are excluded in strict mode.\n\n3. **Ranking Logic**: In soft mode, verify that mainstream articles are always ranked above non-mainstream ones, and that secondary ranking (if implemented) is correct.\n\n4. **Configuration Toggle**: Test that switching between strict and soft modes via configuration produces the expected filtering behavior without requiring a service restart.\n\n5. **No Mainstream Case**: Simulate scenarios where no mainstream articles are present and verify that fallback logic is triggered and flagged appropriately.\n\n6. **Integration**: Mock the city-to-source mapping and test end-to-end filtering/ranking for a variety of city/article combinations.\n\n7. **Type Safety**: Ensure TypeScript type checks pass and that all public methods are properly documented.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Canonical Domain Extraction Utility",
            "description": "Develop a robust utility function to extract the canonical domain from article URLs, handling subdomains, tracking parameters, and internationalized domains using established libraries such as 'tldts' or 'psl'.",
            "dependencies": [],
            "details": "Ensure the utility normalizes domains (e.g., strips 'www', handles unicode domains) and is resilient to malformed or atypical URLs. Integrate comprehensive error handling and document edge cases.",
            "status": "pending",
            "testStrategy": "Write unit tests covering standard, subdomain, internationalized, and malformed URLs. Verify normalization and extraction accuracy for all edge cases."
          },
          {
            "id": 2,
            "title": "Integrate Mainstream Source Matching Logic",
            "description": "Incorporate the city-to-mainstream-sources mapping and implement logic to check if an article's domain matches any whitelisted mainstream domains for the relevant city, ensuring case-insensitive and normalized comparison.",
            "dependencies": [
              "2.1"
            ],
            "details": "Design a matching function that accepts an article domain and city, returning whether the source is mainstream. Ensure the mapping is easily updatable and supports future expansion.",
            "status": "pending",
            "testStrategy": "Test with a variety of city/source combinations, including case and format variations. Confirm correct identification of mainstream and non-mainstream sources."
          },
          {
            "id": 3,
            "title": "Develop Filtering and Ranking Modes with Configurability",
            "description": "Implement strict filtering (only mainstream sources) and soft ranking (prioritize mainstream sources but include all), with a configuration option to toggle modes at runtime.",
            "dependencies": [
              "2.2"
            ],
            "details": "Create a ranking function that boosts mainstream sources and optionally sorts by source prominence. Expose a configuration setting (via config file or environment variable) to switch modes without code changes.",
            "status": "pending",
            "testStrategy": "Write tests to verify correct filtering/ranking in both modes, including configuration toggling and secondary sorting logic."
          },
          {
            "id": 4,
            "title": "Handle Fallback When No Mainstream Articles Are Found",
            "description": "Implement logic to return a clearly flagged fallback list of non-mainstream articles if no mainstream sources are available, and optionally log or track these cases for analytics.",
            "dependencies": [
              "2.3"
            ],
            "details": "Ensure the response structure clearly indicates fallback status. Integrate logging or analytics hooks to monitor fallback occurrences for future review.",
            "status": "pending",
            "testStrategy": "Test fallback behavior by simulating scenarios with and without mainstream articles. Verify correct flagging and logging."
          },
          {
            "id": 5,
            "title": "Ensure Extensibility, SOLID Design, and Comprehensive Testing",
            "description": "Refactor and document the codebase for extensibility (future filtering/ranking criteria), adhere to SOLID principles, isolate filtering logic, and ensure all methods are TypeScript-typed and unit-testable.",
            "dependencies": [
              "2.4"
            ],
            "details": "Use dependency injection for configuration and mappings. Add JSDoc comments and structure code for easy extension. Maintain strict TypeScript typing throughout.",
            "status": "pending",
            "testStrategy": "Review code for SOLID compliance, extensibility, and type safety. Achieve high unit test coverage for all filtering and ranking logic."
          }
        ]
      },
      {
        "id": 3,
        "title": "Enhance Express Backend for Location-Aware Google News Queries",
        "description": "Update the Express backend (dev-server.js) to support Google News RSS queries that adapt to user location, using the 'gl' (country code) and 'hl' (language) parameters, and implement logic to detect country codes from city names.",
        "details": "1. **Parameter Handling**: Refactor the news query endpoint in dev-server.js to accept location input (city name, country, or coordinates) via query parameters or request body. \n\n2. **Location Detection Logic**: Implement a robust mapping from city names to country codes (for 'gl') and language codes (for 'hl'). Use the location-to-news-source data structure from Task 1 as a foundation, and supplement with a reliable geocoding library (such as 'node-geocoder' or 'city-to-country' npm packages) to handle edge cases and international cities. Ensure the mapping covers all cities supported by the frontend and gracefully handles unknown or ambiguous locations by defaulting to a global or English setting.\n\n3. **Google News RSS URL Construction**: Update the logic that builds the Google News RSS URL to dynamically insert the detected 'gl' and 'hl' parameters. For example: `https://news.google.com/rss?hl=en-US&gl=US&ceid=US:en`. Validate that the constructed URLs conform to Google News RSS requirements.\n\n4. **Integration and Error Handling**: Ensure the backend gracefully handles invalid or missing location data, returning meaningful error messages or fallback results. Log location resolution steps for debugging and analytics.\n\n5. **Best Practices**: Use async/await for all network and geocoding operations. Validate and sanitize all user input to prevent injection or malformed requests. Structure code for testability and maintainability, separating location resolution logic into its own module or service.\n\n6. **Documentation**: Document the new endpoint parameters, expected input formats, and example requests/responses in the backend API docs.",
        "testStrategy": "1. **Unit Tests**: Write tests for the location detection module, covering a wide range of city names (including ambiguous, misspelled, and international cases) and verifying correct country and language code resolution.\n\n2. **Integration Tests**: Test the news query endpoint with various location inputs, ensuring the constructed Google News RSS URLs contain the correct 'gl' and 'hl' parameters and return relevant news results.\n\n3. **Error Handling**: Simulate invalid, missing, or unsupported location inputs and verify that the backend responds with appropriate error messages or fallback behavior.\n\n4. **API Documentation Verification**: Confirm that documentation is up-to-date and accurately reflects the new location-aware query capabilities.\n\n5. **Code Quality**: Use static analysis tools (e.g., ESLint) and code reviews to ensure maintainability, security, and adherence to best practices.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor News Query Endpoint for Location Input",
            "description": "Update the Express backend (dev-server.js) news query endpoint to accept location input via query parameters or request body, supporting city name, country, or coordinates.",
            "dependencies": [],
            "details": "Modify the endpoint to parse and validate location-related parameters from incoming requests, ensuring compatibility with both GET and POST methods. Ensure input formats are flexible and well-documented.",
            "status": "pending",
            "testStrategy": "Write endpoint tests to verify correct parsing and validation of location inputs, including edge cases and malformed requests."
          },
          {
            "id": 2,
            "title": "Implement Location Detection and Mapping Logic",
            "description": "Develop robust logic to map city names to country codes ('gl') and language codes ('hl'), leveraging the location-to-news-source data structure and geocoding libraries.",
            "dependencies": [
              "3.1"
            ],
            "details": "Integrate a geocoding library (e.g., 'node-geocoder' or 'city-to-country') to resolve city names to country and language codes. Handle ambiguous or unknown locations by defaulting to global or English settings. Ensure coverage for all frontend-supported cities.",
            "status": "pending",
            "testStrategy": "Create unit tests for the location detection module, covering a wide range of city names, ambiguous cases, and verifying correct code resolution."
          },
          {
            "id": 3,
            "title": "Construct Google News RSS URLs with Location Parameters",
            "description": "Update backend logic to dynamically build Google News RSS URLs using detected 'gl' and 'hl' parameters, ensuring compliance with Google News RSS requirements.",
            "dependencies": [
              "3.2"
            ],
            "details": "Implement URL construction logic that inserts the resolved country and language codes into the RSS query string. Validate URLs against Google News RSS documentation and test with sample requests.",
            "status": "pending",
            "testStrategy": "Write integration tests to verify that constructed URLs are valid and return expected RSS feeds for various location inputs."
          },
          {
            "id": 4,
            "title": "Integrate Error Handling and Logging for Location Resolution",
            "description": "Ensure the backend gracefully handles invalid or missing location data, providing meaningful error messages or fallback results, and logs location resolution steps for debugging and analytics.",
            "dependencies": [
              "3.3"
            ],
            "details": "Implement error handling for all stages of location resolution and RSS URL construction. Log resolution attempts, errors, and fallback actions for monitoring and debugging.",
            "status": "pending",
            "testStrategy": "Test error scenarios including invalid, missing, or ambiguous location inputs, and verify appropriate error responses and logging."
          },
          {
            "id": 5,
            "title": "Apply Best Practices and Document API Changes",
            "description": "Refactor code to use async/await for network and geocoding operations, validate and sanitize user input, and document new endpoint parameters and example requests/responses.",
            "dependencies": [
              "3.4"
            ],
            "details": "Ensure all asynchronous operations use async/await. Validate and sanitize all user inputs to prevent injection and malformed requests. Separate location resolution logic into its own module or service. Update backend API documentation with details on new parameters and usage.",
            "status": "pending",
            "testStrategy": "Review code for async/await usage, input validation, and modularity. Verify documentation accuracy and completeness with example requests and responses."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement UI Indicators for News Source Credibility in NewsDisplay Component",
        "description": "Add visual indicators in the NewsDisplay component to show when articles are from mainstream/trusted sources, including badges next to article titles and a filter toggle to show all sources or only mainstream sources.",
        "details": "1. **Badge Component Creation**: Design and implement a reusable `SourceBadge` component that can be conditionally rendered next to article titles. This component should:\n   - Accept props for source credibility status (mainstream/trusted vs. other)\n   - Support different visual styles based on source type\n   - Include appropriate icons (checkmark, shield, or verification symbol)\n   - Have hover tooltips explaining the badge meaning\n\n2. **NewsDisplay Integration**: Modify the NewsDisplay component to:\n   - Import and utilize the mainstream source detection logic from newsService.ts\n   - For each article, check if its source domain is in the trusted sources list\n   - Conditionally render the appropriate badge component next to article titles\n   - Apply subtle visual differentiation to articles from mainstream sources (e.g., background tint)\n\n3. **Filter Toggle Implementation**:\n   - Add a toggle switch or button group in the NewsDisplay header\n   - Implement state management for the filter preference (all sources vs. mainstream only)\n   - Connect the filter state to the article rendering logic\n   - Ensure the filter state persists across component re-renders\n   - Add smooth transitions when filtering changes the displayed articles\n\n4. **UI/UX Considerations**:\n   - Ensure badges are visually distinct but not distracting\n   - Use appropriate color coding (e.g., green for trusted, neutral for others)\n   - Implement responsive design for badges across different screen sizes\n   - Add accessibility attributes (aria-labels, etc.) for screen readers\n   - Include clear visual feedback when filter state changes\n\n5. **Performance Optimization**:\n   - Memoize source credibility checks to avoid redundant processing\n   - Implement efficient re-rendering when filter state changes\n   - Consider lazy loading for badge icons to minimize initial load time",
        "testStrategy": "1. **Unit Tests**:\n   - Test the `SourceBadge` component in isolation with various props combinations\n   - Verify that the mainstream source detection logic correctly identifies trusted sources\n   - Test filter toggle state management and persistence\n   - Ensure proper conditional rendering based on filter state\n\n2. **Integration Tests**:\n   - Verify that badges appear correctly next to articles from mainstream sources\n   - Test that the filter toggle correctly shows/hides non-mainstream sources\n   - Check that the UI updates appropriately when new articles are loaded\n   - Verify that the filter state is maintained when other UI interactions occur\n\n3. **Visual Regression Tests**:\n   - Capture screenshots of the NewsDisplay with various combinations of mainstream and non-mainstream sources\n   - Verify badge positioning and styling across different viewport sizes\n   - Ensure filter toggle is visually consistent across browsers\n\n4. **User Acceptance Testing**:\n   - Verify that badges are intuitive and their meaning is clear to users\n   - Test that the filter toggle behavior matches user expectations\n   - Ensure the UI remains clean and uncluttered with badges present\n   - Check that accessibility requirements are met for all new UI elements\n\n5. **Performance Testing**:\n   - Measure render time with and without badges to ensure minimal impact\n   - Test filtering performance with large sets of articles\n   - Verify smooth transitions when filter state changes",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement SourceBadge Component",
            "description": "Create a reusable SourceBadge component that visually indicates the credibility status of a news source, supporting different styles and icons for mainstream/trusted versus other sources, and providing explanatory tooltips.",
            "dependencies": [],
            "details": "The component should accept props for source credibility, render appropriate icons (such as checkmark, shield, or verification symbol), and display a tooltip on hover explaining the badge's meaning. Ensure the component is visually distinct but not distracting, and supports responsive design.",
            "status": "pending",
            "testStrategy": "Write unit tests for the SourceBadge component with various prop combinations, verifying correct rendering, icon selection, tooltip display, and accessibility attributes."
          },
          {
            "id": 2,
            "title": "Integrate SourceBadge and Credibility Logic into NewsDisplay",
            "description": "Modify the NewsDisplay component to utilize the mainstream source detection logic, conditionally render the SourceBadge next to article titles, and visually differentiate articles from mainstream sources.",
            "dependencies": [
              "4.1"
            ],
            "details": "Import credibility detection logic from newsService.ts. For each article, check if its source is in the trusted list and render the SourceBadge accordingly. Apply subtle visual cues (e.g., background tint) to articles from mainstream sources.",
            "status": "pending",
            "testStrategy": "Test that NewsDisplay correctly identifies and marks mainstream sources, conditionally renders badges, and applies visual differentiation. Verify integration with the detection logic."
          },
          {
            "id": 3,
            "title": "Implement Filter Toggle for Source Credibility",
            "description": "Add a toggle control in the NewsDisplay header to filter articles by source credibility, manage filter state, and ensure smooth transitions and state persistence.",
            "dependencies": [
              "4.2"
            ],
            "details": "Implement a toggle switch or button group allowing users to select between all sources and mainstream-only. Manage filter state within the component, connect it to article rendering, and persist state across re-renders. Ensure UI transitions are smooth when the filter changes.",
            "status": "pending",
            "testStrategy": "Test filter toggle UI, state management, persistence, and correct filtering of articles. Verify smooth transitions and user feedback when toggling."
          },
          {
            "id": 4,
            "title": "Enhance UI/UX for Credibility Indicators and Filtering",
            "description": "Refine the visual and interactive aspects of badges and filtering, ensuring clarity, accessibility, and responsiveness across devices.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Ensure badges are distinct but not distracting, use appropriate color coding (e.g., green for trusted), and are responsive. Add accessibility features such as aria-labels and clear visual feedback for filter changes.",
            "status": "pending",
            "testStrategy": "Conduct UI/UX reviews and accessibility audits. Test badge visibility, color contrast, responsiveness, and screen reader compatibility. Verify visual feedback for filter state changes."
          },
          {
            "id": 5,
            "title": "Optimize Performance of Credibility Indicators and Filtering",
            "description": "Improve the efficiency of credibility checks and UI updates by memoizing computations, optimizing re-renders, and lazy loading badge assets.",
            "dependencies": [
              "4.2",
              "4.3"
            ],
            "details": "Memoize source credibility checks to avoid redundant processing, optimize component re-renders when filter state changes, and implement lazy loading for badge icons to reduce initial load time.",
            "status": "pending",
            "testStrategy": "Profile component performance, verify memoization effectiveness, measure re-render counts, and test lazy loading of assets under various scenarios."
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Comprehensive Unit Tests for News Source Filtering Functionality",
        "description": "Develop and implement a complete test suite for the news source filtering system, covering domain extraction, source matching, ranking algorithms, fallback behavior, and caching mechanisms.",
        "details": "1. **Domain Extraction Testing**:\n   - Create unit tests for the domain extraction utility that verify correct handling of various URL formats\n   - Test edge cases including subdomains, tracking parameters, query strings, and internationalized domain names\n   - Verify that www prefixes are properly normalized\n   - Test extraction from malformed or unusual URLs\n\n2. **Source Matching Algorithm Tests**:\n   - Develop tests that verify articles from whitelisted domains are correctly identified as mainstream\n   - Test the matching logic against the city-to-mainstream-sources mapping\n   - Include tests for case insensitivity and domain variations\n   - Verify behavior with domains that are substrings of other domains\n\n3. **Ranking System Verification**:\n   - Test that articles are properly ranked according to the implemented ranking criteria\n   - Verify that mainstream sources receive appropriate ranking boosts\n   - Test sorting behavior with mixed mainstream and non-mainstream sources\n   - Ensure consistent ranking behavior across different queries\n\n4. **Fallback Behavior Tests**:\n   - Create tests that simulate scenarios where no mainstream sources are found\n   - Verify the system correctly falls back to showing all sources when no mainstream sources match\n   - Test threshold behavior - when exactly should fallback occur\n   - Ensure user is properly notified when fallback occurs\n\n5. **Cache Behavior Testing**:\n   - Implement tests for the caching mechanism with filtered results\n   - Verify cache hit/miss behavior works correctly\n   - Test cache invalidation and refresh logic\n   - Measure and verify performance improvements from caching\n\n6. **Integration Test Suite**:\n   - Create end-to-end tests that verify the complete filtering pipeline\n   - Test the interaction between UI components and backend filtering logic\n   - Verify filter toggle functionality correctly affects displayed results\n   - Test persistence of filter preferences across sessions",
        "testStrategy": "1. **Unit Test Coverage Verification**:\n   - Use Jest or similar testing framework to achieve >90% code coverage for all filtering-related functions\n   - Implement snapshot testing for predictable components of the filtering system\n   - Create a comprehensive test matrix covering all identified edge cases\n   - Verify tests pass consistently across different environments\n\n2. **Mocking Strategy**:\n   - Create mock data sets representing various news source scenarios\n   - Implement mock responses for external API calls\n   - Use dependency injection to isolate components during testing\n   - Create fixtures for common test scenarios\n\n3. **Integration Testing Approach**:\n   - Set up automated integration tests using Cypress or similar tool\n   - Create test scenarios that simulate real user interactions with filters\n   - Test the complete flow from UI selection to filtered results display\n   - Verify visual indicators correctly reflect mainstream source status\n\n4. **Performance Testing**:\n   - Measure and benchmark filtering performance with large article sets\n   - Test cache hit rates and response time improvements\n   - Verify system performance under load with many concurrent filtering requests\n   - Document performance characteristics and optimization opportunities\n\n5. **Regression Testing**:\n   - Establish baseline tests that can detect regressions in filtering behavior\n   - Automate test runs on each code change affecting the filtering system\n   - Create documentation for manual testing procedures for complex scenarios\n   - Implement CI/CD pipeline integration for continuous test verification",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop Unit Tests for Domain Extraction Utility",
            "description": "Create unit tests to verify the domain extraction utility correctly handles various URL formats, including subdomains, tracking parameters, query strings, internationalized domain names, www prefixes, and malformed URLs.",
            "dependencies": [],
            "details": "Design test cases covering standard and edge-case URLs. Ensure normalization of www prefixes and robust handling of malformed or unusual URLs.",
            "status": "pending",
            "testStrategy": "Use a testing framework (e.g., Jest or Vitest) to achieve high coverage. Include both positive and negative test cases for all URL scenarios."
          },
          {
            "id": 2,
            "title": "Implement Unit Tests for Source Matching Algorithm",
            "description": "Develop tests to verify that the source matching algorithm correctly identifies articles from whitelisted domains as mainstream, handles city-to-mainstream-source mappings, supports case insensitivity, and manages domain substring edge cases.",
            "dependencies": [
              "5.1"
            ],
            "details": "Test matching logic with a variety of domain and city mapping scenarios, including domains that are substrings of others and variations in case.",
            "status": "pending",
            "testStrategy": "Ensure all mapping and matching logic is covered. Include tests for both successful and unsuccessful matches, and verify correct handling of ambiguous cases."
          },
          {
            "id": 3,
            "title": "Verify Ranking System with Unit Tests",
            "description": "Create unit tests to ensure articles are ranked according to the implemented criteria, mainstream sources receive ranking boosts, sorting is correct for mixed sources, and ranking is consistent across queries.",
            "dependencies": [
              "5.2"
            ],
            "details": "Test ranking logic with diverse article sets, including combinations of mainstream and non-mainstream sources, and verify deterministic output.",
            "status": "pending",
            "testStrategy": "Use snapshot and assertion-based tests to confirm ranking order and boosts. Test with varying input data to ensure consistent results."
          },
          {
            "id": 4,
            "title": "Test Fallback Behavior in Filtering Logic",
            "description": "Develop unit tests to simulate scenarios where no mainstream sources are found, verify fallback to all sources, test threshold behavior, and ensure user notification on fallback.",
            "dependencies": [
              "5.3"
            ],
            "details": "Simulate edge cases where filtering yields no mainstream results. Test fallback triggers and user notification mechanisms.",
            "status": "pending",
            "testStrategy": "Assert correct fallback activation and user messaging. Include tests for threshold boundaries and edge-case scenarios."
          },
          {
            "id": 5,
            "title": "Unit Test Caching Mechanisms for Filtered Results",
            "description": "Implement unit tests for the caching layer, verifying cache hit/miss logic, invalidation, refresh behavior, and performance improvements.",
            "dependencies": [
              "5.4"
            ],
            "details": "Test cache population, retrieval, invalidation, and refresh under various filtering scenarios. Measure and assert performance gains from caching.",
            "status": "pending",
            "testStrategy": "Use mocks and spies to simulate cache operations. Include timing and correctness assertions for cache-related behaviors."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-15T23:39:56.102Z",
      "updated": "2025-11-15T23:57:03.884Z",
      "description": "Implement mainstream news source prioritization and filtering for better content quality"
    }
  },
  "watermark": {
    "tasks": [
      {
        "id": "1",
        "title": "Integrate Watermark into Image Generation Pipeline",
        "description": "Apply the existing addWatermark() function to generated cartoon images automatically",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Integrate src/utils/imageUtils.ts addWatermark() into ImageGenerator.tsx. Apply watermark after Gemini returns base64 image, before storing in state. Ensure watermark persists through download and gallery upload.",
        "testStrategy": "Generate a cartoon and verify watermark appears in bottom-right corner. Download image and confirm watermark is present. Upload to gallery and verify watermark is visible.",
        "subtasks": [
          {
            "id": 1,
            "title": "Import addWatermark in ImageGenerator.tsx",
            "description": "Add import statement for the watermark utility",
            "status": "pending",
            "dependencies": [],
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Apply watermark after image generation",
            "description": "Call addWatermark() on base64 image returned from Gemini before setImagePath()",
            "status": "pending",
            "dependencies": [
              "1.1"
            ],
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test watermark on download",
            "description": "Verify downloaded images include watermark",
            "status": "pending",
            "dependencies": [
              "1.2"
            ],
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test watermark on gallery upload",
            "description": "Verify gallery uploads preserve watermark",
            "status": "pending",
            "dependencies": [
              "1.2"
            ],
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-25T07:24:51.948Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-25T07:24:51.949Z",
      "taskCount": 1,
      "completedCount": 1,
      "tags": [
        "watermark"
      ]
    }
  },
  "gallery": {
    "tasks": [
      {
        "id": 1,
        "title": "Add Publish to Gallery Button on ImageGenerator",
        "description": "Add a button that allows users to publish their generated cartoon to the public gallery",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Add 'Publish to Gallery' button next to Download button in ImageGenerator.tsx. Wire up to galleryService.uploadToGallery(). Show confirmation dialog before publishing. Display success/error toast after attempt.",
        "testStrategy": "Generate a cartoon, click Publish to Gallery, confirm in dialog, verify image appears in gallery with correct metadata.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Publish to Gallery button UI",
            "description": "Add styled button next to Download in ImageGenerator.tsx",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Create confirmation dialog component",
            "description": "Modal asking user to confirm gallery publication",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Wire up galleryService.uploadToGallery",
            "description": "Connect button to service with correct parameters",
            "status": "pending",
            "dependencies": [
              "1.1"
            ]
          },
          {
            "id": 4,
            "title": "Add success/error feedback",
            "description": "Show toast or inline message after publish attempt",
            "status": "pending",
            "dependencies": [
              "1.3"
            ]
          }
        ]
      },
      {
        "id": 2,
        "title": "Add Gallery Item Detail View",
        "description": "Create expandable detail view for gallery items with full-size image and metadata",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Add click handler on gallery cards to open detail modal/page. Show full-size image, title, date, news source link, and share buttons.",
        "testStrategy": "Click gallery item, verify detail view opens with all expected information.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Add view_count and share_count to Gallery Schema",
        "description": "Update Supabase schema to track gallery item analytics",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "details": "Add view_count (integer, default 0) and share_count (integer, default 0) columns to news_cartoon_gallery table. Update GalleryItem type. Increment view_count on detail view open.",
        "testStrategy": "Check Supabase schema after migration. Verify counters increment on view/share actions.",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-25T06:28:49.467Z",
      "updated": "2025-11-25T06:28:49.467Z",
      "description": "Public gallery enhancements for publishing and viewing cartoons"
    }
  },
  "social-sharing": {
    "tasks": [
      {
        "id": 1,
        "title": "Create ShareButtons Component",
        "description": "Build reusable component with Twitter, Facebook, LinkedIn, and Copy Link buttons",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Create src/components/share/ShareButtons.tsx. Accept props: title, url, newsUrl (original article). Generate platform-specific share URLs. Include original news article link in share text.",
        "testStrategy": "Render component, click each button, verify correct URL opens or clipboard is populated.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ShareButtons.tsx component file",
            "description": "Set up component structure with TypeScript props interface",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Implement Twitter/X share",
            "description": "Generate Twitter intent URL with text and links",
            "status": "pending",
            "dependencies": [
              "1.1"
            ]
          },
          {
            "id": 3,
            "title": "Implement Facebook share",
            "description": "Generate Facebook sharer URL",
            "status": "pending",
            "dependencies": [
              "1.1"
            ]
          },
          {
            "id": 4,
            "title": "Implement LinkedIn share",
            "description": "Generate LinkedIn share-offsite URL",
            "status": "pending",
            "dependencies": [
              "1.1"
            ]
          },
          {
            "id": 5,
            "title": "Implement Copy Link functionality",
            "description": "Copy gallery URL to clipboard with feedback",
            "status": "pending",
            "dependencies": [
              "1.1"
            ]
          }
        ]
      },
      {
        "id": 2,
        "title": "Add ShareButtons to ImageGenerator",
        "description": "Display share options after cartoon is generated",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Add ShareButtons component below generated image in ImageGenerator.tsx. Pass cartoon title and first selected article URL as newsUrl.",
        "testStrategy": "Generate cartoon, verify share buttons appear, test each share option.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Add ShareButtons to Gallery Detail View",
        "description": "Enable sharing from gallery item detail page",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Add ShareButtons to gallery item detail view. Use gallery item's news_url field for original article attribution.",
        "testStrategy": "Open gallery item detail, verify share buttons present, test sharing functionality.",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Configure Open Graph Meta Tags for Gallery Items",
        "description": "Add proper OG tags for social media previews",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "details": "Implement dynamic OG tags (og:title, og:image, og:description, og:url) for gallery item pages. May require server-side rendering or prerendering strategy.",
        "testStrategy": "Share gallery URL on social platform, verify preview shows correct title, image, and description.",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-25T06:28:49.467Z",
      "updated": "2025-11-25T06:28:49.467Z",
      "description": "Social media sharing with original news article attribution"
    }
  },
  "weather-filter": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Weather Source Blocklist in Backend",
        "description": "Filter out weather-related news sources from Google News RSS results",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Add WEATHER_SOURCES blocklist array in dev-server.js. Include: Weather.com, The Weather Channel, AccuWeather, Weather Underground, National Weather Service, WeatherBug, Weather Network. Filter articles before returning response.",
        "testStrategy": "Search for a location that typically returns weather results. Verify no weather sources appear in results.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define WEATHER_SOURCES blocklist constant",
            "description": "Array of weather-related source names to filter",
            "status": "pending",
            "dependencies": [],
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create filterWeatherSources function",
            "description": "Filter function checking source name against blocklist",
            "status": "pending",
            "dependencies": [
              "1.1"
            ],
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Apply filter in parseGoogleNewsRss",
            "description": "Call filter before returning articles",
            "status": "pending",
            "dependencies": [
              "1.2"
            ],
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add debug logging for filtered articles",
            "description": "Log when articles are filtered (debug mode only)",
            "status": "pending",
            "dependencies": [
              "1.3"
            ],
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-25T06:34:34.308Z"
      },
      {
        "id": 2,
        "title": "Add Weather Keyword Filtering",
        "description": "Filter articles with weather-centric titles",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Extend filtering to check article titles for weather keywords: 'weather forecast', 'temperature alert'. Case-insensitive matching.",
        "testStrategy": "Verify articles with weather keywords in title are filtered out.",
        "subtasks": [],
        "updatedAt": "2025-11-25T06:34:57.776Z"
      },
      {
        "id": 3,
        "title": "Make Weather Filter Configurable",
        "description": "Allow blocklist configuration via environment variable",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "low",
        "details": "Add WEATHER_BLOCKLIST_EXTRA env var to extend default blocklist. Parse comma-separated values.",
        "testStrategy": "Set env var with custom source, verify it gets filtered.",
        "subtasks": [],
        "updatedAt": "2025-11-25T06:35:45.289Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-25T06:35:45.290Z",
      "taskCount": 3,
      "completedCount": 3,
      "tags": [
        "weather-filter"
      ],
      "created": "2025-11-25T07:21:09.359Z",
      "description": "Tasks for weather-filter context",
      "updated": "2025-11-25T07:21:09.359Z"
    }
  },
  "payment": {
    "tasks": [
      {
        "id": 1,
        "title": "Set Up External Donation Page",
        "description": "Create Ko-fi or Buy Me a Coffee account for newscartoon.lol",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Create account on Ko-fi (recommended) or Buy Me a Coffee. Configure donation tiers: $3 Coffee, $5 Lunch, $10 Dinner. Add project description explaining API costs, hosting, and development.",
        "testStrategy": "Verify donation page is accessible and payment works.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Add Support Button to Header",
        "description": "Add 'Support Us' button/link in main navigation",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Add styled button to Layout.tsx header linking to VITE_DONATION_URL. Use heart or coffee icon. Non-intrusive styling.",
        "testStrategy": "Verify button appears in header and links to correct donation page.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add VITE_DONATION_URL environment variable",
            "description": "Configure donation URL in env files",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Create SupportButton component",
            "description": "Styled button/link component for donation",
            "status": "pending",
            "dependencies": [
              "2.1"
            ]
          },
          {
            "id": 3,
            "title": "Add SupportButton to Layout header",
            "description": "Integrate into main navigation",
            "status": "pending",
            "dependencies": [
              "2.2"
            ]
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Donation Prompt After Image Generation",
        "description": "Show non-intrusive donation prompt after successful cartoon generation",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "medium",
        "details": "Create DonationPrompt component shown below generated image. Message: 'Enjoying News Cartoon? Support the project!' with Ko-fi button. Show max once per session using sessionStorage.",
        "testStrategy": "Generate cartoon, verify prompt appears. Refresh and generate again, verify prompt doesn't reappear in same session.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create DonationPrompt component",
            "description": "Non-intrusive prompt with friendly message and button",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Add session tracking to show once",
            "description": "Use sessionStorage to track if prompt was shown",
            "status": "pending",
            "dependencies": [
              "3.1"
            ]
          },
          {
            "id": 3,
            "title": "Integrate prompt into ImageGenerator",
            "description": "Show prompt after successful image generation",
            "status": "pending",
            "dependencies": [
              "3.2"
            ]
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Support/About Page",
        "description": "Dedicated page explaining what donations support",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "low",
        "details": "Create src/pages/SupportPage.tsx. Content: explain Gemini API costs, hosting infrastructure, future development plans. Multiple donation options/tiers. Link from footer.",
        "testStrategy": "Navigate to support page, verify all content displays correctly, donation links work.",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-25T06:28:49.467Z",
      "updated": "2025-11-25T06:28:49.467Z",
      "description": "Payment/donation integration for project sustainability"
    }
  }
}